<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
    
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
     “鼠”于Huafu的“2”！
  </title>
  
  <link rel="shortcut icon" href="http://localhost:4000/blog/favicon.ico" />
  
  <link rel="stylesheet" href="/blog/css/style.css">
  <script src="/blog/js/pace.min.js"></script>

  

  

<link rel="alternate" href="/blog/atom.xml" title="“鼠”于Huafu的“2”！" type="application/atom+xml">
</head>

</html>

<body>
  <div id="app">
    <main class="content">
      
<section class="cover">
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="./images/cover.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/blog/">“鼠”于Huafu的“2”！</a></h1>
      <h2></h2>
      <div>
        
        <img
          src="./mouse.svg"
          class="cover-logo"
          alt="“鼠”于Huafu的“2”！"
        />
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="#main" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>

<div id="main">
  <section class="outer">
  <article class="articles">
    
    <h1 class="page-type-title"></h1>

    
    
    <article id="post-PACKa" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/blog/2020/11/09/PACKa/"
    >包管理工具</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/blog/2020/11/09/PACKa/" class="article-date">
  <time datetime="2020-11-09T08:43:08.000Z" itemprop="datePublished">2020-11-09</time>
</a>
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      


      

      
      <h1 id="包管理工具概述"><a href="#包管理工具概述" class="headerlink" title="包管理工具概述"></a>包管理工具概述</h1><blockquote>
<p>本门课程的前置知识：JavaScript、ES6、模块化、git<br>本门课程的所有代码均书写在 nodejs 环境中，不涉及浏览器环境</p>
</blockquote>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><strong>模块（module）</strong></p>
<p>通常以单个文件形式存在的功能片段，入口文件通常称之为<strong>入口模块</strong>或<strong>主模块</strong></p>
<p><strong>库（library，简称lib）</strong></p>
<p>以一个或多个模块组成的完整功能块，为开发中某一方面的问题提供完整的解决方案</p>
<p><strong>包（package）</strong></p>
<p>包含元数据的库，这些元数据包括：名称、描述、git主页、许可证协议、作者、依赖等等</p>
<p><img src="assets/2019-12-13-10-39-18.png" alt=""></p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>CommonJS 的出现，使 node 环境下的 JS 代码可以用模块更加细粒度的划分。一个类、一个函数、一个对象、一个配置等等均可以作为模块，这种细粒度的划分，是开发大型应用的基石。</p>
<p>为了解决在开发过程中遇到的常见问题，比如加密、提供常见的工具方法、模拟数据等等，一时间，在前端社区涌现了大量的第三方库。这些库使用 CommonJS 标准书写而成，非常容易使用。</p>
<p>然而，在下载使用这些第三方库的时候，遇到难以处理的问题：</p>
<ul>
<li><strong>下载过程繁琐</strong><ul>
<li>进入官网或 github 主页</li>
<li>找到并下载相应的版本</li>
<li>拷贝到工程的目录中</li>
<li>如果遇到有同名的库，需要更改名称</li>
</ul>
</li>
<li><strong>如果该库需要依赖其他库，还需要按照要求先下载其他库</strong></li>
<li><strong>开发环境中安装的大量的库如何在生产环境中还原，又如何区分</strong></li>
<li><strong>更新一个库极度麻烦</strong></li>
<li><strong>自己开发的库，如何在下一次开发使用</strong></li>
</ul>
<p><strong>以上问题，就是包管理工具要解决的问题</strong></p>
<h2 id="前端包管理器"><a href="#前端包管理器" class="headerlink" title="前端包管理器"></a>前端包管理器</h2><blockquote>
<p>本门课程讲解的包管理器<br>npm：重点<br>yarn：次重点<br>其他：了解</p>
</blockquote>
<p>几乎可以这样认为，前端所有的包管理器都是基于 npm 的，目前，npm 即是一个包管理器，也是其他包管理的基石</p>
<p>npm 全称为 node package manager，即 node 包管理器，它运行在 node 环境中，让开发者可以用简单的方式完成包的查找、安装、更新、卸载、上传等操作</p>
<blockquote>
<p>npm 之所以要运行在 node 环境，而不是浏览器环境，根本原因是因为浏览器环境无法提供下载、删除、读取本地文件的功能。而 node 属于服务器环境，没有浏览器的种种限制，理论上可以完全掌控运行 node 的计算机。</p>
</blockquote>
<p>npm 的出现，弥补了 node 没有包管理器的缺陷，于是很快，node 在安装文件中内置了 npm，当开发者安装好 node 之后，就自动安装了 npm，不仅如此，node 环境还专门为 npm 提供了良好的支持，使用 npm 下载的包更加方便了。</p>
<p>npm 由三部分组成：</p>
<ul>
<li>registry：入口<ul>
<li>可以把它想象成一个庞大的数据库</li>
<li>第三方库的开发者，将自己的库按照 npm 的规范，打包上传到数据库中</li>
<li>使用者通过统一的地址下载第三方包</li>
</ul>
</li>
<li>官网：<a href="https://www.npmjs.com/" target="_blank" rel="noopener">https://www.npmjs.com/</a><ul>
<li>查询包</li>
<li>注册、登录、管理个人信息</li>
</ul>
</li>
<li>CLI：command-line interface 命令行接口<ul>
<li>这一部分是本门课讲解的重点</li>
<li>安装好 npm 后，通过 CLI 来使用 npm 的各种功能</li>
</ul>
</li>
</ul>
<blockquote>
<p>node 和 npm 是互相成就的，node 的出现让 npm 火了，npm 的火爆带动了大量的第三方库的发展，很多优秀的第三方库打包上传到了 npm，这些第三方库又为 node 带来了大量的用户</p>
</blockquote>

      
      <!-- 打赏 -->
      
    </div>
    <footer class="article-footer">
      <a data-url="https://huafuhub.github.io/blog/2020/11/09/PACKa/" data-id="ckhacid5u000l74w1900l65qh"
        class="article-share-link">分享</a>
      
    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-MODULEd" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/blog/2020/11/09/MODULEd/"
    >ES6模块化标准</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/blog/2020/11/09/MODULEd/" class="article-date">
  <time datetime="2020-11-09T08:41:20.000Z" itemprop="datePublished">2020-11-09</time>
</a>
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      


      

      
      <h1 id="ES6模块化简介"><a href="#ES6模块化简介" class="headerlink" title="ES6模块化简介"></a>ES6模块化简介</h1><p>ECMA组织参考了众多社区模块化标准，终于在2015年，随着ES6发布了官方的模块化标准，后成为ES6模块化</p>
<p>ES6模块化具有以下的特点</p>
<ol>
<li>使用依赖<strong>预声明</strong>的方式导入模块<ol>
<li>依赖延迟声明<ol>
<li>优点：某些时候可以提高效率</li>
<li>缺点：无法在一开始确定模块依赖关系（比较模糊）</li>
</ol>
</li>
<li>依赖预声明<ol>
<li>优点：在一开始可以确定模块依赖关系</li>
<li>缺点：某些时候效率较低</li>
</ol>
</li>
</ol>
</li>
<li>灵活的多种导入导出方式</li>
<li>规范的路径表示法：所有路径必须以./或../开头</li>
</ol>
<h1 id="基本导入导出"><a href="#基本导入导出" class="headerlink" title="基本导入导出"></a>基本导入导出</h1><h2 id="模块的引入"><a href="#模块的引入" class="headerlink" title="模块的引入"></a>模块的引入</h2><p><strong>注意：这一部分非模块化标准</strong></p>
<p>目前，浏览器使用以下方式引入一个ES6模块文件</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"入口文件"</span> <span class="attr">type</span>=<span class="string">"module"</span>&gt;</span></span></pre></td></tr></table></figure>

<h2 id="模块的基本导出和导入"><a href="#模块的基本导出和导入" class="headerlink" title="模块的基本导出和导入"></a>模块的基本导出和导入</h2><p>ES6中的模块导入导出分为两种：</p>
<ol>
<li>基本导入导出</li>
<li>默认导入导出</li>
</ol>
<p><img src="assets/2019-12-03-17-00-44.png" alt=""></p>
<h3 id="基本导出"><a href="#基本导出" class="headerlink" title="基本导出"></a>基本导出</h3><p>类似于 <code>exports.xxx = xxxx</code></p>
<p>基本导出可以有多个，每个必须有名称</p>
<p>基本导出的语法如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> 声明表达式</span></pre></td></tr></table></figure>

<p>或</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123;具名符号&#125;</span></pre></td></tr></table></figure>

<p>由于基本导出必须具有名称，所以要求导出内容必须跟上<strong>声明表达式</strong>或<strong>具名符号</strong></p>
<h3 id="基本导入"><a href="#基本导入" class="headerlink" title="基本导入"></a>基本导入</h3><p>由于使用的是<strong>依赖预加载</strong>，因此，导入任何其他模块，导入代码必须放置到所有代码之前</p>
<p>对于基本导出，如果要进行导入，使用下面的代码</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;导入的符号列表&#125; <span class="keyword">from</span> <span class="string">"模块路径"</span></span></pre></td></tr></table></figure>

<p>注意以下细节：</p>
<ul>
<li>导入时，可以通过关键字<code>as</code>对导入的符号进行重命名</li>
<li>导入时使用的符号是常量，不可修改</li>
<li>可以使用*号导入所有的基本导出，形成一个对象</li>
</ul>
<h1 id="默认导入导出"><a href="#默认导入导出" class="headerlink" title="默认导入导出"></a>默认导入导出</h1><p><img src="assets/2019-12-03-17-00-44.png" alt=""></p>
<h2 id="默认导出"><a href="#默认导出" class="headerlink" title="默认导出"></a>默认导出</h2><p>每个模块，除了允许有多个基本导出之外，还允许有一个默认导出</p>
<p>默认导出类似于CommonJS中的<code>module.exports</code>，由于只有一个，因此无需具名</p>
<p>具体的语法是</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> 默认导出的数据</span></pre></td></tr></table></figure>

<p>或</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123;默认导出的数据 <span class="keyword">as</span> <span class="keyword">default</span>&#125;</span></pre></td></tr></table></figure>

<p>由于每个模块仅允许有一个默认导出，因此，每个模块不能出现多个默认导出语句</p>
<h2 id="默认导入"><a href="#默认导入" class="headerlink" title="默认导入"></a>默认导入</h2><p>需要想要导入一个模块的默认导出，需要使用下面的语法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> 接收变量名 <span class="keyword">from</span> <span class="string">"模块路径"</span></span></pre></td></tr></table></figure>

<p>类似于CommonJS中的</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 接收变量名 = <span class="built_in">require</span>(<span class="string">"模块路径"</span>)</span></pre></td></tr></table></figure>

<p>由于默认导入时变量名是自行定义的，因此没有别名一说</p>
<p>如果希望同时导入某个模块的默认导出和基本导出，可以使用下面的语法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> 接收默认导出的变量, &#123;接收基本导出的变量&#125; <span class="keyword">from</span> <span class="string">"模块路径"</span></span></pre></td></tr></table></figure>

<p>注：如果使用*号，会将所有基本导出和默认导出聚合到一个对象中，默认导出会作为属性default存在</p>
<h1 id="ES6模块化的其他细节"><a href="#ES6模块化的其他细节" class="headerlink" title="ES6模块化的其他细节"></a>ES6模块化的其他细节</h1><ol>
<li><strong>尽量导出不可变值</strong></li>
</ol>
<p>当导出一个内容时，尽量保证该内容是不可变的（大部分情况都是如此）</p>
<p>因为，虽然导入后，无法更改导入内容，但是在导入的模块内部却有可能发生更改，这将导致一些无法预料的事情发生</p>
<ol start="2">
<li><strong>可以使用无绑定的导入用于执行一些初始化代码</strong></li>
</ol>
<p>如果我们只是想执行模块中的一些代码，而不需要导入它的任何内容，可以使用无绑定的导入：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"模块路径"</span></span></pre></td></tr></table></figure>

<ol start="3">
<li><strong>可以使用绑定再导出，来重新导出来自另一个模块的内容</strong></li>
</ol>
<p>有的时候，我们可能需要用一个模块封装多个模块，然后有选择的将多个模块的内容分别导出，可以使用下面的语法轻松完成</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123;绑定的标识符&#125; <span class="keyword">from</span> <span class="string">"模块路径"</span></span></pre></td></tr></table></figure>

<p><img src="assets/2019-12-04-14-33-14.png" alt=""></p>

      
      <!-- 打赏 -->
      
    </div>
    <footer class="article-footer">
      <a data-url="https://huafuhub.github.io/blog/2020/11/09/MODULEd/" data-id="ckhacid58000k74w1ajdca91j"
        class="article-share-link">分享</a>
      
    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-MODULEc" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/blog/2020/11/09/MODULEc/"
    >AMD与CMD模块化标准</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/blog/2020/11/09/MODULEc/" class="article-date">
  <time datetime="2020-11-09T08:38:12.000Z" itemprop="datePublished">2020-11-09</time>
</a>
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      


      

      
      <h1 id="浏览器端模块化的难题"><a href="#浏览器端模块化的难题" class="headerlink" title="浏览器端模块化的难题"></a>浏览器端模块化的难题</h1><p><strong>CommonJS的工作原理</strong></p>
<p>当使用<code>require(模块路径)</code>导入一个模块时，node会做以下两件事情（不考虑模块缓存）：</p>
<ol>
<li>通过模块路径找到本机文件，并读取文件内容</li>
<li>将文件中的代码放入到一个函数环境中执行，并将执行后module.exports的值作为require函数的返回结果</li>
</ol>
<p>正是这两个步骤，使得CommonJS在node端可以良好的被支持</p>
<p>可以认为，<strong>CommonJS是同步的</strong>，必须要等到加载完文件并执行完代码后才能继续向后执行</p>
<p><strong>当浏览器遇到CommonJS</strong></p>
<p>当想要把CommonJS放到浏览器端时，就遇到了一些挑战</p>
<ol>
<li>浏览器要加载JS文件，需要远程从服务器读取，而网络传输的效率远远低于node环境中读取本地文件的效率。由于CommonJS是同步的，这会极大的降低运行性能</li>
<li>如果需要读取JS文件内容并把它放入到一个环境中执行，需要浏览器厂商的支持，可是浏览器厂商不愿意提供支持，最大的原因是CommonJS属于社区标准，并非官方标准</li>
</ol>
<p><strong>新的规范</strong></p>
<p>基于以上两点原因，浏览器无法支持模块化</p>
<p>可这并不代表模块化不能在浏览器中实现</p>
<p>要在浏览器中实现模块化，只要能解决上面的两个问题就行了</p>
<p>解决办法其实很简单：</p>
<ol>
<li>远程加载JS浪费了时间？做成异步即可，加载完成后调用一个回调就行了</li>
<li>模块中的代码需要放置到函数中执行？编写模块时，直接放函数中就行了</li>
</ol>
<p>基于这种简单有效的思路，出现了AMD和CMD规范，有效的解决了浏览器模块化的问题。</p>
<h1 id="AMD"><a href="#AMD" class="headerlink" title="AMD"></a>AMD</h1><p>全称是Asynchronous Module Definition，即异步模块加载机制</p>
<p>require.js实现了AMD规范</p>
<p>在AMD中，导入和导出模块的代码，都必须放置在define函数中</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">define([依赖的模块列表], <span class="function"><span class="keyword">function</span>(<span class="params">模块名称列表</span>)</span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">//模块内部的代码</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> 导出的内容</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>

<h1 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h1><p>全称是Common Module Definition，公共模块定义规范</p>
<p>sea.js实现了CMD规范</p>
<p>在CMD中，导入和导出模块的代码，都必须放置在define函数中</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params">require, exports, module</span>)</span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">//模块内部的代码</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>
      
      <!-- 打赏 -->
      
    </div>
    <footer class="article-footer">
      <a data-url="https://huafuhub.github.io/blog/2020/11/09/MODULEc/" data-id="ckhacid56000h74w1ao3eflgn"
        class="article-share-link">分享</a>
      
    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-MODULEb" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/blog/2020/11/09/MODULEb/"
    >CommonJS模块化标准</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/blog/2020/11/09/MODULEb/" class="article-date">
  <time datetime="2020-11-09T08:37:12.000Z" itemprop="datePublished">2020-11-09</time>
</a>
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      


      

      
      <h1 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a>CommonJS</h1><p>在nodejs中，由于有且仅有一个入口文件（启动文件），而开发一个应用肯定会涉及到多个文件配合，因此，nodejs对模块化的需求比浏览器端要大的多</p>
<p><img src="assets/2019-12-02-11-15-01.png" alt=""></p>
<p>由于nodejs刚刚发布的时候，前端没有统一的、官方的模块化规范，因此，它选择使用社区提供的CommonJS作为模块化规范</p>
<p>在学习CommonJS之前，首先认识两个重要的概念：<strong>模块的导出</strong>和<strong>模块的导入</strong></p>
<h2 id="模块的导出"><a href="#模块的导出" class="headerlink" title="模块的导出"></a>模块的导出</h2><p>要理解模块的导出，首先要理解模块的含义</p>
<p>什么是模块？</p>
<p>模块就是一个JS文件，它实现了一部分功能，并隐藏自己的内部实现，同时提供了一些接口供其他模块使用</p>
<p>模块有两个核心要素：<strong>隐藏</strong>和<strong>暴露</strong></p>
<p>隐藏的，是自己内部的实现</p>
<p>暴露的，是希望外部使用的接口</p>
<p>任何一个正常的模块化标准，都应该默认隐藏模块中的所有实现，而通过一些语法或api调用来暴露接口</p>
<p><strong>暴露接口的过程即模块的导出</strong></p>
<p><img src="assets/2019-12-02-11-27-12.png" alt=""></p>
<h2 id="模块的导入"><a href="#模块的导入" class="headerlink" title="模块的导入"></a>模块的导入</h2><p>当需要使用一个模块时，使用的是该模块暴露的部分（导出的部分），隐藏的部分是永远无法使用的。</p>
<p><strong>当通过某种语法或api去使用一个模块时，这个过程叫做模块的导入</strong></p>
<h2 id="CommonJS规范"><a href="#CommonJS规范" class="headerlink" title="CommonJS规范"></a>CommonJS规范</h2><p>CommonJS使用<code>exports</code>导出模块，<code>require</code>导入模块</p>
<p>具体规范如下：</p>
<ol>
<li>如果一个JS文件中存在<code>exports</code>或<code>require</code>，该JS文件是一个模块</li>
<li>模块内的所有代码均为隐藏代码，包括全局变量、全局函数，这些全局的内容均不应该对全局变量造成任何污染</li>
<li>如果一个模块需要暴露一些API提供给外部使用，需要通过<code>exports</code>导出，<code>exports</code>是一个空的对象，你可以为该对象添加任何需要导出的内容</li>
<li>如果一个模块需要导入其他模块，通过<code>require</code>实现，<code>require</code>是一个函数，传入模块的路径即可返回该模块导出的整个内容</li>
</ol>
<h2 id="nodejs对CommonJS的实现"><a href="#nodejs对CommonJS的实现" class="headerlink" title="nodejs对CommonJS的实现"></a>nodejs对CommonJS的实现</h2><p>为了实现CommonJS规范，nodejs对模块做出了以下处理</p>
<ol>
<li><p>为了保证高效的执行，仅加载必要的模块。nodejs只有执行到<code>require</code>函数时才会加载并执行模块</p>
</li>
<li><p>为了隐藏模块中的代码，nodejs执行模块时，会将模块中的所有代码放置到一个函数中执行，以保证不污染全局变量。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">//模块中的代码</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">&#125;)()</span></pre></td></tr></table></figure>
</li>
<li><p>为了保证顺利的导出模块内容，nodejs做了以下处理</p>
<ol>
<li>在模块开始执行前，初始化一个值<code>module.exports = {}</code></li>
<li><code>module.exports</code>即模块的导出值</li>
<li>为了方便开发者便捷的导出，nodejs在初始化完<code>module.exports</code>后，又声明了一个变量<code>exports = module.exports</code></li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">module</span>)</span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">module</span>.exports = &#123;&#125;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">var</span> exports = <span class="built_in">module</span>.exports;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">//模块中的代码</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="built_in">module</span>.exports;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">&#125;)()</span></pre></td></tr></table></figure></li>
<li><p>为了避免反复加载同一个模块，nodejs默认开启了模块缓存，如果加载的模块已经被加载过了，则会自动使用之前的导出结果</p>
</li>
</ol>

      
      <!-- 打赏 -->
      
    </div>
    <footer class="article-footer">
      <a data-url="https://huafuhub.github.io/blog/2020/11/09/MODULEb/" data-id="ckhacid55000g74w12mzbcl8i"
        class="article-share-link">分享</a>
      
    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-MODULEa" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/blog/2020/11/09/MODULEa/"
    >模块化发展史</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/blog/2020/11/09/MODULEa/" class="article-date">
  <time datetime="2020-11-09T08:36:17.000Z" itemprop="datePublished">2020-11-09</time>
</a>
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      


      

      
      <h1 id="JavaScript-模块化发展史-ignore"><a href="#JavaScript-模块化发展史-ignore" class="headerlink" title="JavaScript 模块化发展史 {ignore}"></a>JavaScript 模块化发展史 {ignore}</h1><h2 id="第一阶段"><a href="#第一阶段" class="headerlink" title="第一阶段"></a>第一阶段</h2><p>在 JavaScript 语言刚刚诞生的时候，它仅仅用于实现页面中的一些小效果</p>
<p>那个时候，一个页面所用到的 JS 可能只有区区几百行的代码</p>
<p>在这种情况下，语言本身所存在的一些缺陷往往被大家有意的忽略，因为程序的规模实在太小，只要开发人员小心谨慎，往往不会造成什么问题</p>
<p>在这个阶段，也不存在专业的前端工程师，由于前端要做的事情实在太少，因此这一部分工作往往由后端工程师顺带完成</p>
<p>第一阶段发生的大事件：</p>
<ul>
<li>1996年，NetScape将JavaScript语言提交给欧洲的一个标准制定阻止ECMA（欧洲计算机制造商协会）</li>
<li>1998年，NetScape在与微软浏览器IE的竞争中失利，宣布破产</li>
</ul>
<h2 id="第二阶段"><a href="#第二阶段" class="headerlink" title="第二阶段"></a>第二阶段</h2><p>ajax的出现，逐渐改变了 JavaScript 在浏览器中扮演的角色。现在，它不仅可以实现小的效果，还可以和服务器之间进行交互，以更好的体验来改变数据</p>
<p>JS代码的数量开始逐渐增长，从最初的几百行，到后来的几万行，前端程序逐渐变得复杂</p>
<p>后端开发者压力逐渐增加，致使一些公司开始招募专业的前端开发者</p>
<p>但此时，前端开发者的待遇远不及后端开发者，因为前端开发者承担的开发任务相对于后端开发来说，还是比较简单的，通过短短一个月的时间集训，就可以成为满足前端开发的需要</p>
<p>究其根本原因，是因为前端开发还有几个大的问题没有解决，这些问题都严重的制约了前端程序的规模进一步扩大：</p>
<ol>
<li><strong>浏览器解释执行JS的速度太慢</strong></li>
<li><strong>用户端的电脑配置不足</strong></li>
<li>更多的代码带来了全局变量污染、依赖关系混乱等问题</li>
</ol>
<p>上面三个问题，就像是阿喀琉斯之踵，成为前端开发挥之不去的阴影和原罪。</p>
<p>在这个阶段，前端开发处在一个非常尴尬的境地，它在传统的开发模式和前后端分离之间无助的徘徊</p>
<p>第二阶段的大事件：</p>
<ol>
<li>IE浏览器制霸市场后，几乎不再更新</li>
<li>ES4.0流产，导致JS语言10年间几乎毫无变化</li>
<li>2008年ES5发布，仅解决了一些 JS API 不足的糟糕局面</li>
</ol>
<h2 id="第三阶段"><a href="#第三阶段" class="headerlink" title="第三阶段"></a>第三阶段</h2><p>时间继续向前推移，到了2008年，谷歌的 V8 引擎发布，将JS的执行速度推上了一个新的台阶，甚至可以和后端语言媲美。</p>
<p>摩尔定律持续发酵，个人电脑的配置开始飞跃</p>
<p>突然间，制约前端发展的两大问题得以解决，此时，只剩下最后一个问题还在负隅顽抗，即<strong>全局变量污染和依赖混乱</strong>的问题，解决了它，前端便可以突破一切障碍，未来无可限量。</p>
<p>于是，全世界的前端开发者在社区中激烈的讨论，想要为这个问题寻求解决之道……</p>
<p>2008年，有一个名叫 Ryan Dahl 小伙子正在为一件事焦头烂额，它需要在服务器端手写一个高性能的web服务，该服务对于性能要求之高，以至于目前市面上已有的web服务产品都满足不了需求。</p>
<p>经过分析，它确定，如果要实现高性能，那么必须要尽可能的减少线程，而要减少线程，避免不了要实用异步的处理方案。</p>
<p>一开始，他打算自己实用C/C++语言来编写，可是这一过程实在太痛苦。</p>
<p>就在他一筹莫展的时候，谷歌 V8 引擎的发布引起了他的注意，他突然发现，JS不就是最好的实现web服务的语言吗？它天生就是单线程，并且是基于异步的！有了V8引擎的支撑，它的执行速度完全可以撑起一个服务器。而且V8是鼎鼎大名的谷歌公司发布的，谷歌一定会不断的优化V8，有这种又省钱又省力的好事，我干嘛还要自己去写呢？</p>
<p>于是，它基于开源的V8引擎，对源代码作了一些修改，便快速的完成了该项目。</p>
<p>2009年，Ryan推出了该web服务项目，命名为nodejs。</p>
<p>从此，JS第一次堂堂正正的入主后端，不再是必须附属于浏览器的“玩具”语言了。</p>
<p>也是从此刻开始，人们认识到，JS（ES）是一门真正的语言，它依附于运行环境（运行时）（宿主程序）而执行</p>
<p><img src="assets/2019-11-28-15-45-47.png" alt=""></p>
<p>nodejs的诞生，便把JS中的最后一个问题放到了台前，即<strong>全局变量污染和依赖混乱</strong>问题</p>
<p>要直到，nodejs是服务器端，如果不解决这个问题，分模块开发就无从实现，而模块化开发是所有后端程序必不可少的内容</p>
<p>经过社区的激烈讨论，最终，形成了一个模块化方案，即鼎鼎大名的CommonJS，该方案，彻底解决了全局变量污染和依赖混乱的问题</p>
<p>该方案一出，立即被nodejs支持，于是，nodejs成为了第一个为JS语言实现模块化的平台，为前端接下来的迅猛发展奠定了实践基础</p>
<p>该阶段发生的大事件：</p>
<ul>
<li>2008年，V8发布</li>
<li>IE的市场逐步被 firefox 和 chrome 蚕食，现已无力回天</li>
<li>2009年，nodejs发布，并附带commonjs模块化标准</li>
</ul>
<h2 id="第四阶段"><a href="#第四阶段" class="headerlink" title="第四阶段"></a>第四阶段</h2><p>CommonJS的出现打开了前端开发者的思路</p>
<p>既然后端可以使用模块化的JS，作为JS语言的老东家浏览器为什么不行呢？</p>
<p>于是，开始有人想办法把CommonJS运用到浏览器中</p>
<p>可是这里面存在诸多的困难（课程中详解）</p>
<p>办法总比困难多，有些开发者就想，既然CommonJS运用到浏览器困难，我们干嘛不自己重新定一个模块化的标准出来，难道就一定要用CommonJS标准吗？</p>
<p>于是很快，AMD规范出炉，它解决的问题和CommonJS一样，但是可以更好的适应浏览器环境</p>
<p>相继的，CMD规范出炉，它对AMD规范进行了改进</p>
<p>这些行为，都受到了ECMA官方的密切关注……</p>
<p>2015年，ES6发布，它提出了官方的模块化解决方案 —— ES6 模块化</p>
<p>从此以后，模块化成为了JS本身特有的性质，这门语言终于有了和其他语言较量的资本，成为了可以编写大型应用的正式语言</p>
<p>于此同时，很多开发者、技术厂商早已预见到JS的无穷潜力，于是有了下面的故事</p>
<ul>
<li>既然JS也能编写大型应用，那么自然也需要像其他语言那样有解决复杂问题的开发框架<ul>
<li>Angular、React、Vue等前端开发框架出现</li>
<li>Express、Koa等后端开发框架出现</li>
<li>各种后端数据库驱动出现</li>
</ul>
</li>
<li>要开发大型应用，自然少不了各种实用的第三方库的支持<ul>
<li>npm包管理器出现，实用第三方库变得极其方便</li>
<li>webpack等构建工具出现，专门用于打包和部署</li>
</ul>
</li>
<li>既然JS可以放到服务器环境，为什么不能放到其他终端环境呢？<ul>
<li>Electron发布，可以使用JS语言开发桌面应用程序</li>
<li>RN和Vuex等技术发布，可以使用JS语言编写移动端应用程序</li>
<li>各种小程序出现，可以使用JS编写依附于其他应用的小程序</li>
<li>目前还有很多厂商致力于将JS应用到各种其他的终端设备，最终形成大前端生态</li>
</ul>
</li>
</ul>
<blockquote>
<p>可以看到，模块化的出现，是JS通向大型应用的基石，学习好模块化，变具备了编写大型应用的基本功。</p>
</blockquote>

      
      <!-- 打赏 -->
      
    </div>
    <footer class="article-footer">
      <a data-url="https://huafuhub.github.io/blog/2020/11/09/MODULEa/" data-id="ckhacid54000f74w11osydcto"
        class="article-share-link">分享</a>
      
    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-TYPESCRIPTa" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/blog/2020/11/09/TYPESCRIPTa/"
    >typescript --- 应用篇</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/blog/2020/11/09/TYPESCRIPTa/" class="article-date">
  <time datetime="2020-11-09T08:31:26.000Z" itemprop="datePublished">2020-11-09</time>
</a>
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      


      

      
      <h1 id="一、入门"><a href="#一、入门" class="headerlink" title="一、入门"></a>一、入门</h1><h2 id="（一）环境配置"><a href="#（一）环境配置" class="headerlink" title="（一）环境配置"></a>（一）环境配置</h2><ol>
<li>安装 typescript<blockquote>
<p>yarn global add typescript</p>
</blockquote>
</li>
<li>配置 node 环境<blockquote>
<p>yarn add @types/node</p>
</blockquote>
</li>
<li>简化流程<blockquote>
<p>yarn add ts-node<br>yarn add nodemon</p>
</blockquote>
</li>
</ol>
<hr>
<h2 id="（二）基础"><a href="#（二）基础" class="headerlink" title="（二）基础"></a>（二）基础</h2><h3 id="1-基本类型"><a href="#1-基本类型" class="headerlink" title="1.基本类型"></a>1.基本类型</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> str: <span class="built_in">string</span> = <span class="string">''</span><span class="comment">//字符串</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> num: <span class="built_in">number</span> = <span class="number">1</span><span class="comment">//数字</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> bol: <span class="built_in">boolean</span> = <span class="literal">true</span><span class="comment">//布尔</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj: object = &#123;&#125;<span class="comment">//对象</span></span></pre></td></tr></table></figure>

<h3 id="2-数组约束"><a href="#2-数组约束" class="headerlink" title="2.数组约束"></a>2.数组约束</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr1: <span class="built_in">any</span>[] = []<span class="comment">//数组，数组项可以是任意类型</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr2: <span class="built_in">Array</span>&lt;<span class="built_in">any</span>&gt; = []<span class="comment">//数组，数组项可以是任意类型</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr3: [] = [<span class="string">''</span>, <span class="number">10</span>]<span class="comment">//数组，数组项可以是字符串或数字</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr4: [<span class="built_in">string</span>, <span class="built_in">number</span>] = [<span class="string">''</span>, <span class="number">10</span>]<span class="comment">//数组，数组项可以是字符串或数字</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr5: (<span class="built_in">string</span>|<span class="built_in">number</span>)[] = [<span class="string">''</span>, <span class="number">10</span>]<span class="comment">//数组，数组项可以是字符串或数字</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr6: readonly <span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]<span class="comment">//只读数组</span></span></pre></td></tr></table></figure>

<h3 id="3-函数约束"><a href="#3-函数约束" class="headerlink" title="3.函数约束"></a>3.函数约束</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//无返回值</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">string</span></span>): <span class="title">void</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">  <span class="built_in">console</span>.log(<span class="string">'hello'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//永不结束</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">string</span></span>): <span class="title">never</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">while</span>(<span class="literal">true</span>)&#123;&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数重载</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn3</span>(<span class="params">a:<span class="built_in">number</span>, b:<span class="built_in">number</span></span>):<span class="title">number</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="function"><span class="keyword">function</span> <span class="title">fn3</span>(<span class="params">a:<span class="built_in">string</span>, b:<span class="built_in">string</span></span>):<span class="title">string</span></span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="function"><span class="function"><span class="keyword">function</span> <span class="title">fn3</span>(<span class="params">a: <span class="built_in">number</span> | <span class="built_in">string</span>, b: <span class="built_in">number</span> | <span class="built_in">string</span></span>):<span class="title">number</span> | <span class="title">string</span> </span>&#123;</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="function">  <span class="title">if</span> (<span class="params"><span class="keyword">typeof</span> a === "<span class="built_in">number</span>" &amp;&amp; <span class="keyword">typeof</span> b === "<span class="built_in">number</span>"</span>) </span>&#123;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line"><span class="function">    <span class="title">return</span> <span class="title">a</span> * <span class="title">b</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line"><span class="function">  &#125;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line"><span class="function">  <span class="title">else</span> <span class="title">if</span> (<span class="params"><span class="keyword">typeof</span> a === "<span class="built_in">string</span>" &amp;&amp; <span class="keyword">typeof</span> a === "<span class="built_in">string</span>"</span>) </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> a + b</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"a 和 b 类型必须相同！"</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//                              可选参数     默认参数</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">a: <span class="built_in">number</span> | <span class="built_in">string</span>, b?: <span class="built_in">string</span>, c: <span class="built_in">string</span> = "c"</span>): <span class="title">void</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> a === <span class="string">"number"</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">//类型保护</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">console</span>.log(a)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">  <span class="built_in">console</span>.log(b, c)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="4-类型别名"><a href="#4-类型别名" class="headerlink" title="4.类型别名"></a>4.类型别名</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//类型别名</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Type1 = <span class="string">'1'</span> | <span class="string">'2'</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Type2 = <span class="function">(<span class="params">a: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">string</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Type3 = &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">  (a: <span class="built_in">string</span>): <span class="built_in">string</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Type4 = &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">  T1?: <span class="string">'1'</span> | <span class="string">'2'</span><span class="comment">//成员可选</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">  readonly T2: readonly <span class="built_in">number</span>[]<span class="comment">//只读成员</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">  T3(a: <span class="built_in">number</span>): <span class="built_in">number</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">  T4: <span class="function">(<span class="params">a: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">string</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//组合</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> A = &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">  a: <span class="built_in">string</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> B = &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">  b: <span class="built_in">number</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> C = &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">  c: <span class="built_in">boolean</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">&#125; &amp; A &amp; B</span></pre></td></tr></table></figure>

<h3 id="5-枚举"><a href="#5-枚举" class="headerlink" title="5.枚举"></a>5.枚举</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Enum &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  prop1 = <span class="string">"abc"</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">  prop2 = <span class="number">123</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> data: Enum;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">data = Enum.prop1 <span class="comment">// "abc"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">data = Enum.prop2 <span class="comment">// 123</span></span></pre></td></tr></table></figure>

<h3 id="6-接口"><a href="#6-接口" class="headerlink" title="6.接口"></a>6.接口</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//接口</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Type1 &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">  (a: <span class="built_in">string</span>): <span class="built_in">string</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Type2 &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">  T1?: <span class="string">'1'</span> | <span class="string">'2'</span><span class="comment">//成员可选</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">  readonly T2: readonly <span class="built_in">number</span>[]<span class="comment">//只读成员</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">  T3(a: <span class="built_in">number</span>): <span class="built_in">number</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">  T4: <span class="function">(<span class="params">a: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">string</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//继承</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> A &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">  a: <span class="built_in">string</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> B &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">  b: <span class="built_in">number</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> C <span class="keyword">extends</span> A, B&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">  c: <span class="built_in">boolean</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="7-类"><a href="#7-类" class="headerlink" title="7.类"></a>7.类</h3><ul>
<li>属性列表描述</li>
<li>属性描述符</li>
<li>权限描述符</li>
<li>严格属性初始化</li>
<li>访问器属性<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> User&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">//属性列表描述</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">//权限描述符</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">public</span> name: <span class="built_in">string</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">protected</span> sex: <span class="string">"male"</span> | <span class="string">"female"</span> = <span class="string">"male"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">private</span> _age: <span class="built_in">number</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">//属性描述符</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">//语法糖，自动描述和赋值</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">constructor</span>(<span class="params">readonly area: <span class="built_in">string</span>, like?:<span class="built_in">string</span></span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">//访问器属性</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">set</span> age(newValue) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">this</span>._age = newValue</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">get</span> age() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._age</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="8-泛型"><a href="#8-泛型" class="headerlink" title="8.泛型"></a>8.泛型</h3><ul>
<li>函数泛型</li>
<li>类泛型</li>
<li>接口泛型</li>
<li>类型别名泛型</li>
<li>泛型约束（继承）</li>
<li>多泛型</li>
</ul>
<h3 id="9-类型兼容性"><a href="#9-类型兼容性" class="headerlink" title="9.类型兼容性"></a>9.类型兼容性</h3><ul>
<li>断言：<ul>
<li><type>data 断言</li>
<li>data as type 断言</li>
<li>data! 非空断言</li>
</ul>
</li>
<li>函数：<ul>
<li>参数：只能少，不能多</li>
<li>返回值：要求返回必须返回，不要求则随意</li>
</ul>
</li>
<li>对象：<ul>
<li>赋值：鸭子辨型法，成员只能多，不能少</li>
<li>字面量：严格完全匹配</li>
</ul>
</li>
</ul>
<hr>
<h2 id="（三）模块化"><a href="#（三）模块化" class="headerlink" title="（三）模块化"></a>（三）模块化</h2><h3 id="1-ES6-模块化标准"><a href="#1-ES6-模块化标准" class="headerlink" title="1.ES6 模块化标准"></a>1.ES6 模块化标准</h3><ul>
<li>export 声明</li>
<li>export default 默认导出</li>
<li>import 变量 from ‘path’</li>
</ul>
<h3 id="2-commonJS-模块化标准"><a href="#2-commonJS-模块化标准" class="headerlink" title="2.commonJS 模块化标准"></a>2.commonJS 模块化标准</h3><ul>
<li>exports.属性</li>
<li>module.export = {}</li>
<li>const 变量 require(‘path’)</li>
</ul>
<hr>
<h1 id="二、进阶"><a href="#二、进阶" class="headerlink" title="二、进阶"></a>二、进阶</h1><h2 id="（一）面向对象"><a href="#（一）面向对象" class="headerlink" title="（一）面向对象"></a>（一）面向对象</h2><h3 id="1-类的继承"><a href="#1-类的继承" class="headerlink" title="1.类的继承"></a>1.类的继承</h3><ul>
<li>A extends B<ul>
<li>A继承自B</li>
<li>A是子类、B是父类</li>
<li>子类拥有父类的所有成员</li>
<li>子类可以重写父类成员</li>
<li>this指向是动态的</li>
<li>super指向父类</li>
</ul>
</li>
<li>A instanceof B <ul>
<li>A是不是一个B</li>
<li>子类对象始终可以赋值给父类对象，当只能使用父类定义的成员，应使用类型保护</li>
<li>单根性：每个类只有一个父类（避免多继承）</li>
<li>传递性：隔代也是父子</li>
</ul>
</li>
<li>修饰符<ul>
<li>public 均可以访问</li>
<li>protected 自身及子类可以访问</li>
<li>private 自身可访问</li>
</ul>
</li>
</ul>
<h3 id="2-抽象类"><a href="#2-抽象类" class="headerlink" title="2.抽象类"></a>2.抽象类</h3><ul>
<li>abstract<ul>
<li>某个类只表示一个抽象的概念，只用于提取子类共有的成员，而不能直接创建对象</li>
<li>抽象成员，父类只知道类型，不知道具体的实现，且子类必须要将其实现</li>
</ul>
</li>
<li>模板模式<ul>
<li>所有子类实现某个方法流程一致，只有某一步骤不一致<ul>
<li>可能出现大量重复代码</li>
<li>重复代码提取后，可能出现调用顺序紊乱</li>
</ul>
</li>
<li>将该方法提取到父类实现</li>
<li>将不一致的地方提取到父类为抽象方法，让子类去具体实现</li>
<li>在父类方法中使用抽象方法</li>
</ul>
</li>
</ul>
<h3 id="3-静态成员"><a href="#3-静态成员" class="headerlink" title="3.静态成员"></a>3.静态成员</h3><ul>
<li>static<ul>
<li>某个成员属于类本身，而不是具体的对象</li>
<li>静态方法中this指向当前类</li>
</ul>
</li>
<li>单例模式<ul>
<li>某些类的实例对象，在系统中最多只能有一个（避免随意创建）</li>
<li>将构造函数私有 private</li>
<li>定义一个私有的静态属性，用于存储实例对象</li>
<li>定义一个公有的静态方法，用于得到实例对象<ul>
<li>判断静态属性是否已经有值，有值则直接返回该实例</li>
<li>没有则创建一个实例并赋值给静态属性，然后返回该实例</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="4-接口"><a href="#4-接口" class="headerlink" title="4.接口"></a>4.接口</h3><ul>
<li>implements<ul>
<li>表达某个类是否拥有某种能力（是否实现某个接口）</li>
</ul>
</li>
<li>类型保护函数<ul>
<li>参数：param</li>
<li>返回值：param is interface</li>
</ul>
</li>
<li>接口可继承类<ul>
<li>interface C extends A, B {}</li>
<li>用A、B类的所有成员实现一个类型</li>
</ul>
</li>
</ul>
<h3 id="5-索引器"><a href="#5-索引器" class="headerlink" title="5.索引器"></a>5.索引器</h3><ul>
<li>[prop: string]: any</li>
<li>[prop: number]: any<ul>
<li>索引器需书写于类的最顶端（所有成员之前）</li>
<li>可拓展对象</li>
<li>除了类定义的成员外，可通过索引器进行成员拓展</li>
<li>默认情况下，索引器可越过类型检查，需配置noImplicitAny</li>
<li>在js中所有的成员名，包括数组索引都是字符串类型，成员名在使用数字类型时，会进行隐式类型转换</li>
<li>在ts中成员名类型需要与索引器匹配</li>
</ul>
</li>
</ul>
<h3 id="6-this指向约束"><a href="#6-this指向约束" class="headerlink" title="6.this指向约束"></a>6.this指向约束</h3><ul>
<li>全局直接调用<ul>
<li>严格模式：this指向undefined</li>
<li>非严格模式：this指向全局对象</li>
</ul>
</li>
<li>对象方法调用<ul>
<li>this指向对象本身</li>
</ul>
</li>
<li>事件处理函数调用<ul>
<li>this指向事件处理对象</li>
</ul>
</li>
<li>箭头函数<ul>
<li>this指向声明位置的this指向</li>
</ul>
</li>
<li>bind、apply、call手动绑定this<ul>
<li>this指向绑定值</li>
</ul>
</li>
<li>在ts中默认与js一致，严格this指向约束，需配置noImplicitThis</li>
<li>在函数声明时，用第一个参数位置约定this指向</li>
</ul>
<h3 id="7-装饰器"><a href="#7-装饰器" class="headerlink" title="7.装饰器"></a>7.装饰器</h3><ul>
<li><strong>约束类</strong><ul>
<li>new () =&gt; object</li>
<li>()内约束构造函数参数</li>
</ul>
</li>
<li><strong>装饰类</strong><ul>
<li>本质是一个函数</li>
<li>参数：类本身</li>
<li>返回值：<ul>
<li>void：仅运行函数</li>
<li>class：替换原来的类</li>
</ul>
</li>
<li>运行时间<ul>
<li>定义类之后立即运行</li>
<li>多个装饰器，按栈的结构顺序运行（新进后出）</li>
</ul>
</li>
</ul>
</li>
<li><strong>装饰成员</strong><ul>
<li>本质是一个函数</li>
<li>参数：<ul>
<li>参数1：<ul>
<li>静态成员：类本身</li>
<li>实例成员：类原型</li>
</ul>
</li>
<li>参数2：成员名</li>
<li>参数3：Object.defineProperty</li>
</ul>
</li>
<li>返回值：<ul>
<li>void：仅运行函数</li>
<li>any：替换原来的成员</li>
</ul>
</li>
</ul>
</li>
<li><strong>reflect-metadata</strong><ul>
<li>第三方库</li>
<li>用于保存元数据</li>
</ul>
</li>
<li><strong>class-validator</strong><ul>
<li>第三方库</li>
<li>用于验证</li>
</ul>
</li>
<li><strong>class-transformer</strong><ul>
<li>第三方库</li>
<li>用于将平面对象转换为类对象</li>
</ul>
</li>
</ul>
<hr>
<h2 id="（二）类型演算"><a href="#（二）类型演算" class="headerlink" title="（二）类型演算"></a>（二）类型演算</h2><h3 id="1-关键字"><a href="#1-关键字" class="headerlink" title="1.关键字"></a>1.关键字</h3><ul>
<li>typeof</li>
<li>keyof</li>
<li>in</li>
</ul>
<h3 id="2-预设"><a href="#2-预设" class="headerlink" title="2.预设"></a>2.预设</h3><ul>
<li>Partial<T> 所有成员可选</li>
<li>Require<T> 所有成员必填</li>
<li>Readonly<T> 所有成员只读</li>
<li>Exclude&lt;T, U&gt; 剔除可以赋予给U的类型</li>
<li>Extract&lt;T, U&gt; 保留可以赋予给U的类型</li>
<li>NonNullable<T> 剔除null、undefined</li>
<li>ReturnType<typrof fn> 得到某个函数的返回类型 </li>
<li>InstanceType<typrof cl> 得到某个类的实例类型 </li>
</ul>
<hr>
<h2 id="（三）声明文件"><a href="#（三）声明文件" class="headerlink" title="（三）声明文件"></a>（三）声明文件</h2>
      
      <!-- 打赏 -->
      
    </div>
    <footer class="article-footer">
      <a data-url="https://huafuhub.github.io/blog/2020/11/09/TYPESCRIPTa/" data-id="ckhacid5v000n74w12jnvdtsh"
        class="article-share-link">分享</a>
      
    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-REACTa" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/blog/2020/11/09/REACTa/"
    >react --- 应用篇</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/blog/2020/11/09/REACTa/" class="article-date">
  <time datetime="2020-11-09T08:30:06.000Z" itemprop="datePublished">2020-11-09</time>
</a>
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      


      

      
      <h1 id="一、开发环境"><a href="#一、开发环境" class="headerlink" title="一、开发环境"></a>一、开发环境</h1><h2 id="（一）浏览器"><a href="#（一）浏览器" class="headerlink" title="（一）浏览器"></a>（一）浏览器</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- react --&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">crossorigin</span> <span class="attr">src</span>=<span class="string">"https://unpkg.com/react@16/umd/react.development.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- react-dom --&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">crossorigin</span> <span class="attr">src</span>=<span class="string">"https://unpkg.com/react-dom@16/umd/react-dom.development.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- babel --&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://unpkg.com/babel-standalone@6.15.0/babel.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/babel"</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="actionscript"><span class="comment">// 使用jsx语法</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></pre></td></tr></table></figure>

<h2 id="（二）脚手架"><a href="#（二）脚手架" class="headerlink" title="（二）脚手架"></a>（二）脚手架</h2><ul>
<li><p>使用npm安装并使用</p>
<blockquote>
<p>cnpm install -g create-react-app<br>create-react-app my-app<br>cd my-app/<br>npm start</p>
</blockquote>
</li>
<li><p>使用yarn安装并使用</p>
<blockquote>
<p>yarn create react-app projectName</p>
</blockquote>
</li>
</ul>
<h2 id="（三）辅助功能"><a href="#（三）辅助功能" class="headerlink" title="（三）辅助功能"></a>（三）辅助功能</h2><ul>
<li>使用vscode编辑器<ul>
<li>配置emmet.includeLanguages支持jsx语法</li>
</ul>
</li>
<li>使用vscode插件<ul>
<li>ESLint代码风格实时检查</li>
<li>ES7 React/Redux/GraphQL/React-Native snippets代码模板快速生成</li>
</ul>
</li>
<li>使用Chrome浏览器<ul>
<li>React Developer Tools调试工具</li>
<li>Redux DevTools调试工具</li>
</ul>
</li>
</ul>
<hr>
<h1 id="二、React-核心"><a href="#二、React-核心" class="headerlink" title="二、React 核心"></a>二、React 核心</h1><p><a href="https://zh-hans.reactjs.org/docs/react-api.html" target="_blank" rel="noopener">React</a></p>
<p><a href="https://zh-hans.reactjs.org/docs/react-dom.html" target="_blank" rel="noopener">React Dom</a></p>
<h2 id="（一）JSX语法"><a href="#（一）JSX语法" class="headerlink" title="（一）JSX语法"></a>（一）JSX语法</h2><h3 id="1-书写规范"><a href="#1-书写规范" class="headerlink" title="1.书写规范"></a>1.书写规范</h3><ul>
<li>JSX语法本质是React.createElement()语法糖，在使用jsx语法的地方必须引用React模块</li>
<li>jsx表达式建议放在（）内</li>
<li>jsx表达式有且只有一个根节点，期望使用多个根节点时可使用React.Fragment元素包裹（使用语法糖&lt;&gt;&lt;/&gt;）</li>
<li>jsx表达式中每个元素必须结束（遵循XML规范）</li>
</ul>
<h3 id="2-嵌入js表达式"><a href="#2-嵌入js表达式" class="headerlink" title="2.嵌入js表达式"></a>2.嵌入js表达式</h3><h4 id="（1）插入元素内容"><a href="#（1）插入元素内容" class="headerlink" title="（1）插入元素内容"></a>（1）插入元素内容</h4><ul>
<li>使用{}进行表达式插入，{}内支持js表达式<ul>
<li>支持React元素对象，不支持普通对象，普通对象不能作为子元素</li>
<li>支持数组，进行遍历数组，数组项会被作为子元素，如果数组项是元素需要绑定key属性，key属性不会反应到真实DOM</li>
</ul>
</li>
<li>{}内结果如果是null、undefined、false不会作为子元素</li>
<li>jsx注释{/*…*/}</li>
</ul>
<h4 id="（2）插入元素属性"><a href="#（2）插入元素属性" class="headerlink" title="（2）插入元素属性"></a>（2）插入元素属性</h4><ul>
<li>属性使用小驼峰命名</li>
<li>元素属性值可以使用{}插入js表达式</li>
<li>className属性并不支持一个数组</li>
<li>style属性支持一个普通对象，对应css样式</li>
<li>dangerouslySetInnerHTML属性需要一个对象，对象带有一个__html属性，属性值使用innerHtml设置<ul>
<li>jsx默认使用innerText设置内容</li>
<li>自动编码，防止注入攻击</li>
</ul>
</li>
</ul>
<h3 id="3-元素不可变"><a href="#3-元素不可变" class="headerlink" title="3.元素不可变"></a>3.元素不可变</h3><ul>
<li>本质是Object.freeze()冻结了对象</li>
<li>子元素及属性均只可读，不可写</li>
</ul>
<hr>
<h2 id="（二）组件"><a href="#（二）组件" class="headerlink" title="（二）组件"></a>（二）组件</h2><h3 id="1-内置组件"><a href="#1-内置组件" class="headerlink" title="1.内置组件"></a>1.内置组件</h3><ul>
<li>html元素</li>
<li>React.Fragment组件</li>
<li>React.createContext().Provider组件</li>
<li>React.createContext().Consumer组件</li>
<li>React.StrictMode组件（严格模式）<ul>
<li>不会参与UI渲染</li>
<li>识别不安全的生命周期</li>
<li>检测意外的副作用</li>
<li>检测过时API</li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-函数组件"><a href="#2-函数组件" class="headerlink" title="2.函数组件"></a>2.函数组件</h3><h4 id="（1）参数"><a href="#（1）参数" class="headerlink" title="（1）参数"></a>（1）参数</h4><ul>
<li>组件属性对象props</li>
</ul>
<h4 id="（2）返回值"><a href="#（2）返回值" class="headerlink" title="（2）返回值"></a>（2）返回值</h4><ul>
<li>React元素</li>
</ul>
<h4 id="（3）HOOK"><a href="#（3）HOOK" class="headerlink" title="（3）HOOK"></a>（3）HOOK</h4><ul>
<li>React &gt;= 16.8.0版本新增</li>
</ul>
<hr>
<h3 id="3-类组件"><a href="#3-类组件" class="headerlink" title="3.类组件"></a>3.类组件</h3><h4 id="（1）继承"><a href="#（1）继承" class="headerlink" title="（1）继承"></a>（1）继承</h4><ul>
<li>React.Component</li>
</ul>
<h4 id="（2）render-方法"><a href="#（2）render-方法" class="headerlink" title="（2）render()方法"></a>（2）render()方法</h4><ul>
<li>返回React元素</li>
</ul>
<h4 id="（3）属性"><a href="#（3）属性" class="headerlink" title="（3）属性"></a>（3）属性</h4><ul>
<li>constructor(props)构造函数方法拿到属性对象</li>
<li>super(props)将属性对象传递给父类</li>
<li>组件内通过this.props即可使用属性对象</li>
</ul>
<h4 id="（4）状态"><a href="#（4）状态" class="headerlink" title="（4）状态"></a>（4）状态</h4><ul>
<li>组件自己维护的数据，本质是类组件的一个属性（一个对象）</li>
<li>状态初始化：<ul>
<li>constructor构造函数内初始化</li>
<li>class字段初始化</li>
</ul>
</li>
<li>状态的改变：<ul>
<li>状态不能直接改变，必须使用this.setState()</li>
<li>状态的改变可能是异步的，若处于html事件中，则是异步的，否则是同步的<ul>
<li>this.setState(obj)，接受一个对象，与this.state进行混合并重新渲染（Object.assign(this.state, obj)）</li>
<li>this.setState(func)，接受一个函数，该函数有一个参数prev代表上一次的状态对象，返回一个对象与之前的状态进行混合（该函数会异步执行）</li>
<li>this.setState(obj | func, callback)接受第二个参数是一个回调函数，该回调在所有状态改变完成，重新渲染之后运行，在回调中获取的是最新状态</li>
</ul>
</li>
<li>React会对异步的this.setState()进行优化，将多次状态进行合并，所有状态改变完成后统一对this.state进行改变，然后进行重新渲染</li>
</ul>
</li>
</ul>
<h4 id="（5）声生命周期"><a href="#（5）声生命周期" class="headerlink" title="（5）声生命周期"></a>（5）声生命周期</h4><ul>
<li><p><strong>React &lt; 16.0.0版本</strong></p>
</li>
<li><p>constrouctor()</p>
<ul>
<li>组件初始化</li>
<li>同一个组件对象只会创建一次</li>
<li>禁止使用setState()</li>
</ul>
</li>
<li><p>render()</p>
<ul>
<li>构建虚拟DOM树并渲染真实DOM节点</li>
<li>禁止使用setState()</li>
</ul>
</li>
<li><p>componentDidMount()</p>
<ul>
<li>组件挂在完成</li>
<li>可以使用setState()</li>
<li>常用于副作用处理（网络请求、启动计时器）</li>
</ul>
</li>
<li><p>shouldComponentUpdate()</p>
<ul>
<li>参数1：新属性</li>
<li>参数2：新状态</li>
<li>返回值：boolean，是否重新渲染</li>
<li>用于性能优化</li>
</ul>
</li>
<li><p>componentWillUnMount()</p>
<ul>
<li>组件卸载</li>
<li>用于销毁组件依赖资源（取消计时器）<img src='./old.png' />
</li>
</ul>
</li>
<li><p><strong>React &gt;= 16.0.0版本</strong></p>
</li>
<li><p>取消一些钩子函数：</p>
<ul>
<li>componentWillMount() 可能会有BUG</li>
<li>componentWillReceiveProps() 反模式问题</li>
<li>componentWillUpdate() 没有实际意义</li>
</ul>
</li>
<li><p>增加一些钩子函数：</p>
<ul>
<li>static getDerivedStateFromProps()<ul>
<li>静态函数，无法使用setState()</li>
<li>运行在初始化、属性变化、状态变化之后</li>
<li>参数1：新属性</li>
<li>参数2：新状态</li>
<li>返回值：Object，与状态进行混合</li>
</ul>
</li>
<li>getSnapshotBeforeUpdate()<ul>
<li>运行在DOM树构建完毕，页面即将渲染之前</li>
<li>参数1：旧属性</li>
<li>参数2：旧状态</li>
<li>返回值：componentDidUpdate()的第三个参数<img src='./new.png' />
</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="4-表单"><a href="#4-表单" class="headerlink" title="4. 表单"></a>4. 表单</h3><ul>
<li>默认情况下表单是非受控组件<ul>
<li>可以使用 defaultValue、 defaultChecked属性指定默认值</li>
<li>使用ref来操作真实DOM间接获得组件内容</li>
</ul>
</li>
<li>通过指定内容和事件使得表单成为受控组件<ul>
<li>使用value指定组件内容（来源于状态）</li>
<li>使用onChange()事件改编组件内容（改编状态）</li>
</ul>
</li>
</ul>
<hr>
<h3 id="5-HOC高阶组件"><a href="#5-HOC高阶组件" class="headerlink" title="5.HOC高阶组件"></a>5.HOC高阶组件</h3><ul>
<li>高阶组件是函数组件（通常以with前缀命名）<ul>
<li>参数：接受一个组件</li>
<li>返回值：返回一个组件</li>
</ul>
</li>
<li>利用高阶组件实现横切关注点<ul>
<li>抽离共同的功能</li>
<li>添加额外功能</li>
</ul>
</li>
<li>注意：<ul>
<li>不要在render()中使用高阶组件，会导致组件对象被重复销毁和创建</li>
<li>不要在高阶组件内修改传入的组件</li>
</ul>
</li>
</ul>
<hr>
<h3 id="6-纯组件"><a href="#6-纯组件" class="headerlink" title="6.纯组件"></a>6.纯组件</h3><h4 id="（1）PureComponent类组件"><a href="#（1）PureComponent类组件" class="headerlink" title="（1）PureComponent类组件"></a>（1）PureComponent类组件</h4><ul>
<li>作用于类组件</li>
<li>一个组件，如果某个组件继承自它，该组件会被优化</li>
<li>状态和属性会进行浅比较，如果没有变化，则不会重新渲染</li>
<li>本质就是优化了shouldComponentUpdate()</li>
</ul>
<h4 id="（2）React-memo-高阶组件"><a href="#（2）React-memo-高阶组件" class="headerlink" title="（2）React.memo()高阶组件"></a>（2）React.memo()高阶组件</h4><ul>
<li>作用于函数组件</li>
<li>本质就是给函数组件包裹了一层类组件，类组件继承PureComponent</li>
</ul>
<hr>
<h3 id="7-Portals插槽"><a href="#7-Portals插槽" class="headerlink" title="7.Portals插槽"></a>7.Portals插槽</h3><ul>
<li>不改变虚拟DOM树结构的情况下，将React元素渲染到指定的真实DOM容器中</li>
<li>使用ReactDOM.createPortals(React元素，真实DOM)<ul>
<li>参数1：需要渲染的React元素</li>
<li>参数2：真实DOM容器</li>
<li>返回值：一个ReactPortals组件</li>
</ul>
</li>
<li>注意事件冒泡<ul>
<li>React中的事件是被包装过的</li>
<li>React中的事件冒泡是根据虚拟DOM树结构冒泡的，与真实DOM层次结构无关</li>
</ul>
</li>
</ul>
<hr>
<h2 id="（三）属性"><a href="#（三）属性" class="headerlink" title="（三）属性"></a>（三）属性</h2><h3 id="1-数据传递"><a href="#1-数据传递" class="headerlink" title="1.数据传递"></a>1.数据传递</h3><ul>
<li>组件内部数据来源于状态state</li>
<li>组件内部数据来源于属性props</li>
<li>组件内部数据来源于上下文Context</li>
<li>组件使用者通过属性向组件内部传递数据<ul>
<li>传递普通数据</li>
<li>传递自定义事件处理程序</li>
<li>传递子元素（props.children）语法糖可以直接向html一样书写子元素</li>
</ul>
</li>
<li>组件内通过自定义事件参数向外部使用者传递数据</li>
</ul>
<h3 id="2-事件"><a href="#2-事件" class="headerlink" title="2.事件"></a>2.事件</h3><h4 id="（1）定义"><a href="#（1）定义" class="headerlink" title="（1）定义"></a>（1）定义</h4><ul>
<li>React事件本质就是一个属性，属性值是一个函数，遵循小驼峰命名</li>
<li>内置组件的事件与html事件保持一致</li>
<li>自定义组件的事件就是一个属性，在组件内部合适的时候调用该方法</li>
<li>在事件处理程序中，如果没有特殊处理，this指向undefined<ul>
<li>使用bind绑定this</li>
<li>使用箭头函数（字段初始化）</li>
</ul>
</li>
</ul>
<h4 id="（2）React事件"><a href="#（2）React事件" class="headerlink" title="（2）React事件"></a>（2）React事件</h4><ul>
<li>研究对象：内置html组件的事件</li>
<li>事件委托：本质只给document注册事件，几乎所有元素的事件处理，均在document事件中进行<ul>
<li>对于不会冒泡的事件或某些元素独有的事件则是在DOM元素自身上进行监听的</li>
<li>当在document中监听到某个事件的时候，查看虚拟DOM树中哪些元素注册了此事件，按照虚拟DOM树冒泡的顺序依次执行</li>
<li>当给真实DOM和虚拟DOM注册事件的时候，无论DOM层次结构如何，真实DOM永远先运行，因为虚拟DOM事件要等冒泡到document时才会运行</li>
<li>如果给真实DOM注册事件并阻止了冒泡，会导致虚拟DOM中的事件无法运行</li>
<li>如果给虚拟DOM注册事件并阻止了冒泡，本质上阻止的是document的冒泡并标记该虚拟DOM，在循环运行事件的时候会忽略被标记的事件<ul>
<li>所以阻止不了真实DOM事件</li>
<li>阻止的是虚拟DOM树的冒泡</li>
</ul>
</li>
</ul>
</li>
<li>事件对象：React中的事件对象是合成事件对象<ul>
<li>如果要是用真实事件对象，通过e.nativeEvent获得</li>
<li>如果是用e.nativeEvent中的方法，已经发生在冒泡到document事件中，可能不会符合预期</li>
<li>React中事件对象会被重用<ul>
<li>在事件处理程序中不要异步使用事件对象，事件处理程序结束时该对象会被重置，准备给下一个事件处理程序使用</li>
<li>通过e.persist()方法对事件对象持久化</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="3-属性默认值"><a href="#3-属性默认值" class="headerlink" title="3.属性默认值"></a>3.属性默认值</h3><ul>
<li>通过静态属性 defaultProps指定属性默认值</li>
<li>函数组件：funcName.defaultProps = {}</li>
<li>类组件：static defaultProps = {}</li>
</ul>
<h3 id="4-属性类型检查"><a href="#4-属性类型检查" class="headerlink" title="4.属性类型检查"></a>4.属性类型检查</h3><ul>
<li>使用prop-types库和静态属性propTypes 定义检查规则<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">PropTypes.any：<span class="comment">//任意类型</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">PropTypes.array：<span class="comment">//数组类型</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">PropTypes.bool：<span class="comment">//布尔类型</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">PropTypes.func：<span class="comment">//函数类型</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">PropTypes.number：<span class="comment">//数字类型</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">PropTypes.object：<span class="comment">//对象类型</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">PropTypes.string：<span class="comment">//字符串类型</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">PropTypes.symbol：<span class="comment">//符号类型</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">PropTypes.node：<span class="comment">//任何可以被渲染的内容，字符串、数字、React元素</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">PropTypes.element：<span class="comment">//react元素</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">PropTypes.elementType：<span class="comment">//react元素类型</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">PropTypes.instanceOf(构造函数)：<span class="comment">//必须是指定构造函数的实例</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">PropTypes.oneOf([xxx, xxx])：<span class="comment">//枚举</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">PropTypes.oneOfType([xxx, xxx]);  <span class="comment">//属性类型必须是数组中的其中一个</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">PropTypes.arrayOf(PropTypes.XXX)：<span class="comment">//必须是某一类型组成的数组</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">PropTypes.objectOf(PropTypes.XXX)：<span class="comment">//对象由某一类型的值组成</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">PropTypes.shape(对象): <span class="comment">//属性必须是对象，并且满足指定的对象要求</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">PropTypes.exact(&#123;...&#125;)：<span class="comment">//对象必须精确匹配传递的数据</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//自定义属性检查，如果有错误，返回错误对象即可</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">属性: <span class="function"><span class="keyword">function</span>(<span class="params">props, propName, componentName</span>) </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">   <span class="comment">//...</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h3 id="5-Ref"><a href="#5-Ref" class="headerlink" title="5.Ref"></a>5.Ref</h3><h4 id="（1）定义-1"><a href="#（1）定义-1" class="headerlink" title="（1）定义"></a>（1）定义</h4><ul>
<li>作用位置：<ul>
<li>作用于内置html元素：得到的是真实DOM元素</li>
<li>作用于类组件：得到的是组件实例对象</li>
<li>不能作用于函数组件</li>
</ul>
</li>
<li>作用形式：<ul>
<li>字符串：<ul>
<li>给组件定义一个ref属性，属性值为字符串str，代表该组件ref存储位置的变量名str</li>
<li>通过this.refs对象的str属性获取ref</li>
<li>不建议使用</li>
</ul>
</li>
<li>对象：<ul>
<li>通过React.createRef()创建一个对象obj，该对象本质就是一个普通对象，拥有一个current属性，属性值为null，给组件定义一个ref属性，属性值为该对象obj</li>
<li>通过传递的对象obj.current获得ref</li>
</ul>
</li>
<li>函数：<ul>
<li>给组件定义一个ref属性，属性值为一个函数func<ul>
<li>该函数会在componentDidMount()调用一次</li>
<li>如果给ref属性重新赋值一个新函数，则旧函数和新函数会在componentWillUpdate()之前分别调用一次</li>
<li>该函数会在componentWillUnMount()调用一次</li>
</ul>
</li>
<li>通过传递的函数func的第一个参数获得ref</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="（2）转发"><a href="#（2）转发" class="headerlink" title="（2）转发"></a>（2）转发</h4><ul>
<li>需求：不期望获得组件本身，而是获得组件内部的子元素</li>
<li>实现：使用高阶组件React.forwardRef()进行ref转发<ul>
<li>参数：接受一个函数组件funcComp</li>
<li>返回值：一个新函数组件newFuncComp<ul>
<li>给新组件newFuncComp定义ref</li>
<li>该ref会被高阶组件React.forwardRef()传递给被包装的组件funcComp的第二个参数</li>
<li>在组件funcComp内通过第二个参数获得ref，并自定义ref指向（或赋值或指向子元素ref）</li>
<li>若ref被指向子元素ref，高阶组件使用者就可以获得函数组件内部的子元素真实DOM或组件实例对象</li>
</ul>
</li>
</ul>
</li>
<li>拓展：<ul>
<li>不使用高阶组件React.forwardRef()也可以使用一个普通属性实现（只是不能定义为ref属性）</li>
<li>高阶组件React.forwardRef()不接受类组件，使用一个函数将其包装一下即可</li>
<li>对自定义高阶组件实现ref转发</li>
</ul>
</li>
</ul>
<hr>
<h3 id="6-render-Props"><a href="#6-render-Props" class="headerlink" title="6.render Props"></a>6.render Props</h3><ul>
<li>组件功能及其处理逻辑一致，只是显示有差异，则可以通过以下方法解决：<ul>
<li>HOC高阶组件提取功能</li>
<li>render props渲染属性<ul>
<li>给render属性传递一个函数，组件内部调用此函数<ul>
<li>函数参数为数据对象</li>
<li>函数返回值为渲染的内容</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="（四）上下文"><a href="#（四）上下文" class="headerlink" title="（四）上下文"></a>（四）上下文</h2><h3 id="1-特点"><a href="#1-特点" class="headerlink" title="1.特点"></a>1.特点</h3><ul>
<li>某个组件创建了上下文，上下文中的数据会被所有后代组件共享</li>
<li>某个组件依赖了上下文，该组件则不再纯粹（复用性变低，数据管理变复杂）</li>
<li>通常情况下，上下文用于第三方组件（通用组件）</li>
</ul>
<h3 id="2-React-lt-16-0-0版本"><a href="#2-React-lt-16-0-0版本" class="headerlink" title="2.React &lt; 16.0.0版本"></a>2.React &lt; 16.0.0版本</h3><h4 id="（1）创建"><a href="#（1）创建" class="headerlink" title="（1）创建"></a>（1）创建</h4><ul>
<li>只有类组件可以创建上下文</li>
<li>给类组件定义静态属性 static childContextTypes = {} 约束上下文中的数据类型</li>
<li>给类组件定义实例方法 getChildContext()<ul>
<li>该方法会在render()后被自动调用</li>
<li>方法返回值 Object, 定义上下文中的数据，必须满足类型约束</li>
</ul>
</li>
</ul>
<h4 id="（2）获取"><a href="#（2）获取" class="headerlink" title="（2）获取"></a>（2）获取</h4><ul>
<li>给组件定义静态属性 contextTypes = {} 声明并约束需要使用的数据和类型（通常提取类型约定childContextTypes和contextTypes必须保持一致）</li>
<li>在类组件构造函数constructor(props, context)中第二个参数即可获得上下文对象（该对象只包含声明过的数据，并非全部）<ul>
<li>将context交给super(props, context)</li>
<li>在组建内即可使用this.context获得上下文对象</li>
</ul>
</li>
<li>在函数组件中直接从第二个参数获得上下文对象</li>
</ul>
<h4 id="（3）改变"><a href="#（3）改变" class="headerlink" title="（3）改变"></a>（3）改变</h4><ul>
<li>上下文的改变不可以直接改变，源于状态和属性的改变而改变（状态和属性的改变则会重新渲染，渲染后getChildContext()会被自动调用，保持最新上下文）</li>
<li>若子组件使用者想实现改变上下文，通过上下文提供方法，子组件通过调用方法，让父组件创建者自己去改变数据</li>
</ul>
<h4 id="（4）多个上下文"><a href="#（4）多个上下文" class="headerlink" title="（4）多个上下文"></a>（4）多个上下文</h4><ul>
<li>组件不会从自身创建的上下文中去获取数据</li>
<li>组件获取是就近原则，从最近的上下文中优先获取</li>
</ul>
<h3 id="3-React-gt-16-0-0版本"><a href="#3-React-gt-16-0-0版本" class="headerlink" title="3.React &gt;= 16.0.0版本"></a>3.React &gt;= 16.0.0版本</h3><h4 id="（1）上下文是一个独立的对象，使用React-createContext-创建"><a href="#（1）上下文是一个独立的对象，使用React-createContext-创建" class="headerlink" title="（1）上下文是一个独立的对象，使用React.createContext()创建"></a>（1）上下文是一个独立的对象，使用React.createContext()创建</h4><ul>
<li>参数：Object, 默认值</li>
<li>返回值：Object, 上下文对象<ul>
<li><strong>Provider属性：生产者</strong><ul>
<li>一个组件，包裹上下文区域（包裹子元素）</li>
<li>创建上下文，该组件value属性给上下文赋予数据</li>
</ul>
</li>
<li><strong>Consumer属性：消费者</strong><ul>
<li>一个组件，当做子元素使用</li>
<li>该组件children属性值接受一个函数<ul>
<li>函数第一个参数即获得上下文对象</li>
<li>函数返回值会被渲染</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="（2）多个上下文对应多个上下文对象"><a href="#（2）多个上下文对应多个上下文对象" class="headerlink" title="（2）多个上下文对应多个上下文对象"></a>（2）多个上下文对应多个上下文对象</h4><ul>
<li>Provider禁止复用，应重新React.createContext()创建</li>
<li>创建者和使用者应对应同一个上下文对象<ul>
<li>contextType == React.createContext()</li>
<li>context.Provider &lt;==&gt; context.Consumer</li>
</ul>
</li>
</ul>
<h4 id="（3）context-Provider的value属性发生变化会强制更新"><a href="#（3）context-Provider的value属性发生变化会强制更新" class="headerlink" title="（3）context.Provider的value属性发生变化会强制更新"></a>（3）context.Provider的value属性发生变化会强制更新</h4><ul>
<li>其包裹区域所有元素会被强制重新渲染，无论子元素是否使用上下文</li>
<li>无视性能优化，shouldComponentUpdate()不会被执行</li>
<li>value变化比较的是地址（Object.is()）</li>
<li>通过保持value属性值的引用不变而避免强制更新（优化性能）</li>
<li>在类组件中如果想实现手动强制刷新，调用this.forceUpdate()函数即可</li>
</ul>
<hr>
<h2 id="（五）错误与渲染"><a href="#（五）错误与渲染" class="headerlink" title="（五）错误与渲染"></a>（五）错误与渲染</h2><h3 id="1-错误边界（React-gt-16-0-0）"><a href="#1-错误边界（React-gt-16-0-0）" class="headerlink" title="1.错误边界（React &gt;= 16.0.0）"></a>1.错误边界（React &gt;= 16.0.0）</h3><ul>
<li>在React中，如果某个元素在渲染期间出现了错误，则整个组件树会被卸载</li>
<li>利用错误边界处理错误，自定义一个高阶组件，有能力捕获子元素在渲染期间发生的错误并阻止其继续传播<ul>
<li>方法1：编写静态生命周期函数 static getDerivedStateFromError()<ul>
<li>参数：错误对象</li>
<li>返回值：一个对象Object，该对象会与状态进行混合</li>
<li>触发条件：只有子组件在渲染期间发生错误，才会运行该函数</li>
<li>触发时间：在渲染子组件过程中，发生错误后，更新页面之前运行</li>
<li>处理错误：有机会预先通过状态来处理错误</li>
</ul>
</li>
<li>方法2：编写生命周期函数 componentDidCatch()<ul>
<li>参数1：错误对象</li>
<li>参数2：错误摘要</li>
<li>触发条件：只有子组件在渲染期间发生错误，才会运行该函数</li>
<li>触发时间：在渲染子组件过程中，发生错误后，更新页面之后运行（运行时间点靠后，如果改变状态，性能低下）</li>
<li>处理错误：在生命周期函数内改变状态，有机会预先通过状态来处理错误（通常只用于记录错误信息）</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-节点创建与挂载"><a href="#2-节点创建与挂载" class="headerlink" title="2.节点创建与挂载"></a>2.节点创建与挂载</h3><ul>
<li>react元素：通过React.createElement()创建的对象</li>
<li>react节点：根据react元素创建用于渲染UI页面的对象</li>
<li>通过节点对象生成虚拟DOM树<ul>
<li>根据不同的节点类型做不同的事情</li>
<li>对于文本节点，关联React节点与真实文本节点</li>
<li>对于DOM节点，关联React节点与真实DOM节点，设置真实DOM的各种属性</li>
<li>对于类组件节点，关联React节点与实例对象，运行生命周期方法<ul>
<li>对render()返回的节点内容进行操作</li>
<li>将componentDidMount()加入执行队列</li>
</ul>
</li>
</ul>
</li>
<li>将生成的虚拟DOM树保存起来，供后续使用</li>
<li>将真实的DOM节点添加到容器中，然后运行执行队列（子组件的componentDidMount()会先运行）</li>
</ul>
<table>
<thead>
<tr>
<th align="left">react元素类型</th>
<th align="left">非react元素类型</th>
<th align="left">react节点类型</th>
<th align="left">react节点创建</th>
<th align="left">后续操作</th>
</tr>
</thead>
<tbody><tr>
<td align="left">string（内置组件）</td>
<td align="left">/</td>
<td align="left">DOM节点</td>
<td align="left">document.createElement()</td>
<td align="left">操作子元素</td>
</tr>
<tr>
<td align="left">function（函数组件）</td>
<td align="left">/</td>
<td align="left">组件节点</td>
<td align="left">调用函数得到节点内容</td>
<td align="left">操作节点内容</td>
</tr>
<tr>
<td align="left">class（类组件）</td>
<td align="left">/</td>
<td align="left">组件节点</td>
<td align="left">创建该类的实例对象</td>
<td align="left">运行生命周期</td>
</tr>
<tr>
<td align="left">/</td>
<td align="left">string（字符串）</td>
<td align="left">文本节点</td>
<td align="left">docuemnt.createTextNode()</td>
<td align="left">/</td>
</tr>
<tr>
<td align="left">/</td>
<td align="left">number（数字）</td>
<td align="left">文本节点</td>
<td align="left">docuemnt.createTextNode()</td>
<td align="left">/</td>
</tr>
<tr>
<td align="left">/</td>
<td align="left">boolean（布尔值）</td>
<td align="left">空节点</td>
<td align="left">占位</td>
<td align="left">/</td>
</tr>
<tr>
<td align="left">/</td>
<td align="left">null（空）</td>
<td align="left">空节点</td>
<td align="left">占位</td>
<td align="left">/</td>
</tr>
<tr>
<td align="left">/</td>
<td align="left">undefined（未定义）</td>
<td align="left">空节点</td>
<td align="left">占位</td>
<td align="left">/</td>
</tr>
<tr>
<td align="left">/</td>
<td align="left">array（数组）</td>
<td align="left">数组节点</td>
<td align="left">docuemnt.createDocumentFragment()</td>
<td align="left">操作数组项</td>
</tr>
</tbody></table>
<hr>
<h3 id="3-节点更新与卸载"><a href="#3-节点更新与卸载" class="headerlink" title="3.节点更新与卸载"></a>3.节点更新与卸载</h3><h4 id="（1）更新场景与流程："><a href="#（1）更新场景与流程：" class="headerlink" title="（1）更新场景与流程："></a>（1）更新场景与流程：</h4><ul>
<li>ReactDOM.render()根节点开始更新<ul>
<li>进入根节点的 <strong><font color=red>对比更新（diff）</font></strong></li>
</ul>
</li>
<li>setState()以该实例对象所在的组件节点为根节点的分支开始更新<ul>
<li>运行生命周期：static getDerivedStateFromProps()</li>
<li>运行生命周期：shouldComponentUpdate()<ul>
<li>返回值：false ==&gt; 结束</li>
<li>返回值：true ==&gt; 继续更新</li>
</ul>
</li>
<li>运行生命周期：render()<ul>
<li>得到一个新节点，进入新节点的 <strong><font color=red>对比更新（diff）</font></strong></li>
</ul>
</li>
<li>将生命周期加入队列：getSnapshotBeforeUpdate()</li>
<li>将生命周期加入队列：componentDidUpdate()</li>
</ul>
</li>
<li>更新虚拟DOM树</li>
<li>更新真实DOM</li>
<li>执行队列中的生命周期：componentDidMount()()</li>
<li>执行队列中的生命周期：getSnapshotBeforeUpdate()</li>
<li>执行队列中的生命周期：componentDidUpdate()</li>
<li>运行生命周期：componentWillUnMount()</li>
</ul>
<h4 id="（2）对比更新"><a href="#（2）对比更新" class="headerlink" title="（2）对比更新"></a>（2）对比更新</h4><ul>
<li>本质：将产生的新节点与之前虚拟DOM树中的节点进行对比，发现差异，完成更新</li>
<li>问题：与之前虚拟DOM树中的哪个节点对比？</li>
<li>假设：<ul>
<li>节点不会出现层次移动，利用树的深度直接定位层级</li>
<li>同一层级不同节点类型会生成不同的结构</li>
<li>同一层级相同节点类型的多个兄弟节点使用Key进行标识<ul>
<li>同一层级没有key，节点按照顺序对比</li>
<li>同一层级若有key，节点按key确定对比目标（key不同直接走没有对比目标）</li>
</ul>
</li>
</ul>
</li>
<li>结果：<ul>
<li>找到了对比目标，判断节点类型<ul>
<li>类型相同：针对类型做 <strong><font color=green>对应更新</font></strong></li>
<li>类型不同：<strong><font color=blue>卸载旧节点</font></strong>，创建新节点</li>
</ul>
</li>
<li>没有找到对比目标，判断节点的增减<ul>
<li>创建增加的节点，走创建流程</li>
<li>卸载多余的节点，走卸载流程</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="（3）对应更新"><a href="#（3）对应更新" class="headerlink" title="（3）对应更新"></a>（3）对应更新</h4><ul>
<li>若之前虚拟DOM树中React节点有关联真实DOM，则重用关联的真实DOM，记录变化的属性</li>
<li>若之前虚拟DOM树中React节点有关联实例对象，则重用关联的实例对象，运行生命周期方法</li>
<li>函数组件节点：直接调用函数，递归对比更新</li>
<li>空节点：不做任何事</li>
<li>数组节点：遍历数组，逐一递归对比更新</li>
</ul>
<h4 id="（4）卸载节点"><a href="#（4）卸载节点" class="headerlink" title="（4）卸载节点"></a>（4）卸载节点</h4><ul>
<li>先创建新节点，再卸载旧节点，然后挂载新节点</li>
<li>非类组件节点：直接放弃该节点，如果有子节点，递归卸载子节点</li>
<li>类组件节点：<ul>
<li>直接放弃该节点，如果有子节点，递归卸载子节点</li>
<li>运行声明周期：componentWillUnMount()</li>
<li>在卸载过程中componentWillUnMount()不会加入队列而是直接执行</li>
<li>先卸载当前节点再递归卸载子节点，当前节点componentWillUnMount()会先运行</li>
</ul>
</li>
<li>不同类型的节点会假设生成不同的结构<ul>
<li>父节点不同，整个分支会被卸载重建</li>
<li>子节点没有机会进行对比更新</li>
<li>应尽量不要去改变节点类型</li>
</ul>
</li>
<li>在虚拟DOM树中是按位置进行对比的<ul>
<li>节点在树中的位置变化直接影响对比对象会发生变化</li>
<li>应尽量利用样式控制节点的显示隐藏</li>
<li>应充分利用空节点保持结构的稳定</li>
</ul>
</li>
</ul>
<hr>
<h3 id="4-Profiler调试工具"><a href="#4-Profiler调试工具" class="headerlink" title="4.Profiler调试工具"></a>4.Profiler调试工具</h3><ul>
<li>可用于性能分析 </li>
</ul>
<hr>
<h2 id="（六）HOOK"><a href="#（六）HOOK" class="headerlink" title="（六）HOOK"></a>（六）HOOK</h2><h3 id="1-State-Hook"><a href="#1-State-Hook" class="headerlink" title="1.State Hook"></a>1.State Hook</h3><h4 id="（1）注册"><a href="#（1）注册" class="headerlink" title="（1）注册"></a>（1）注册</h4><ul>
<li>API：React.useState()</li>
<li>功能：为函数组件添加状态，只能在函数内部使用</li>
<li>参数：Any，状态默认值（默认undefined）</li>
<li>返回值：Array，一个长度为2的数组<ul>
<li>数组第一项：状态数据</li>
<li>数组第一项：状态改变方法</li>
</ul>
</li>
</ul>
<h4 id="（2）原理"><a href="#（2）原理" class="headerlink" title="（2）原理"></a>（2）原理</h4><ul>
<li>第一次创建节点的时候给组件节点创建一个状态表格</li>
<li>在第n次调用useState()，检查状态表格是否存在下标n<ul>
<li>不存在：使用默认值创建一个状态，加入状态表格，下标为n</li>
<li>若存在：忽略默认值，直接返回下标为n的状态</li>
</ul>
</li>
<li>每个组件的状态表格是独立的，互不影响</li>
<li>一个组件可有多个状态，状态应定义在函数体顶部，便于阅读</li>
<li>严禁在代码块（判断、循环）内定义，会导致状态对应紊乱</li>
<li>状态对应的改变方法的引用是固定的，节约内存空间</li>
<li>调用状态改变方法改变状态，状态数据不会混合，而是直接覆盖替换，建议对多个数据使用多个状态，分别管理</li>
<li>某些状态之间没有必然联系，应分化为不同的状态，而不要合在一起</li>
<li>状态发生改变，组件会被重现渲染，但是调用状态改变方法，若数据没有变化（Object.is(old, new)）不会导致重现渲染</li>
<li>如果要实现强制刷新，可使用默认值为空对象的状态改变方法 const [, forceUpdate] = useState({})</li>
<li>状态的改变可能是异步的，对状态改变方法传递一个函数，函数参数是上一次的状态且是可信任的</li>
</ul>
<hr>
<h3 id="2-Effect-Hook"><a href="#2-Effect-Hook" class="headerlink" title="2.Effect Hook"></a>2.Effect Hook</h3><h4 id="（1）注册-1"><a href="#（1）注册-1" class="headerlink" title="（1）注册"></a>（1）注册</h4><ul>
<li>API：<ul>
<li>React.useEffect()</li>
<li>React.useLayoutEffect()</li>
</ul>
</li>
<li>功能：为函数组件注册副作用处理函数，只能在函数内部使用</li>
<li>参数1：function，副作用处理函数<ul>
<li>参数：undefined，没有参数</li>
<li>返回值：function，清理函数</li>
</ul>
</li>
<li>参数2：Array，依赖项<ul>
<li>使用一个空数组作为依赖项，则副作用处理函数仅会在首次渲染时运行一次，清理函数仅会在组件销毁时运行一次</li>
</ul>
</li>
<li>返回值：undefined，没有返回值</li>
</ul>
<h4 id="（2）副作用处理函数"><a href="#（2）副作用处理函数" class="headerlink" title="（2）副作用处理函数"></a>（2）副作用处理函数</h4><ul>
<li>运行时间点：<ul>
<li>React.useEffect()：<ul>
<li>副作用处理函数在修改真实DOM之后，界面UI完成渲染之后异步运行</li>
<li>推荐使用React.useEffect()，不会导致页面渲染阻塞</li>
</ul>
</li>
<li>React.useLayoutEffect()：<ul>
<li>类组件生命周期方法在修改真实DOM之后，界面UI尚未渲染之前同步运行</li>
<li>与类组件中componentDidMount()、componentDidUpdate()一致</li>
</ul>
</li>
<li>如果注册了依赖项，只有依赖数据发生变化才会运行</li>
</ul>
</li>
<li>注册副作用处理函数与State类似<ul>
<li>严禁在代码块（判断、循环）内注册</li>
<li>一个组件可以注册多个副作用处理函数</li>
<li>多个副作用函数按照注册顺序依次执行</li>
</ul>
</li>
<li><font color=red>在副作用函数内使用了函数上下文中的数据，由于闭包影响，数据更新可能会非实时</font><ul>
<li>副作用处理函数是异步函数，函数内使用外部上下文中的数据状态会指向定义时的状态，而非调用时的状态</li>
<li>如果在定义到调用期间使用的数据状态发生了改变，则调用时的结果可能会不如预期</li>
</ul>
</li>
<li>副作用函数的重复注册执行的是覆盖，应保持副作用函数和清理函数的稳定</li>
</ul>
<h4 id="（3）清理函数"><a href="#（3）清理函数" class="headerlink" title="（3）清理函数"></a>（3）清理函数</h4><ul>
<li>副作用处理函数可以有返回值，返回一个函数，叫做清理函数</li>
<li>清理函数会在合适的时候被自动调用：<ul>
<li>组件首次渲染时不会运行</li>
<li>组件销毁时会运行</li>
<li>在每次副作用处理函数运行之前运行</li>
<li>如果注册了依赖项，只有在组件销毁时才会运行</li>
</ul>
</li>
</ul>
<hr>
<h3 id="3-自定义-Hook"><a href="#3-自定义-Hook" class="headerlink" title="3.自定义 Hook"></a>3.自定义 Hook</h3><ul>
<li>API：React.useHookName()</li>
<li>功能：使用一个函数提取封装通用Hook功能</li>
<li>语法：使用use前缀命名</li>
<li>优势：对比高阶组件和render Props<ul>
<li>用函数封装功能，使用和理解更容易</li>
<li>不会改变组件结构，没有复杂的嵌套结构</li>
<li>Hook可以进行自定义分化，将复杂的数据和功能拆分，横切关注点</li>
</ul>
</li>
</ul>
<h3 id="4-Context-Hook"><a href="#4-Context-Hook" class="headerlink" title="4.Context Hook"></a>4.Context Hook</h3><ul>
<li>API：React.useContext()</li>
<li>功能：用于获取上下文中的数据</li>
<li>目的：减少组件嵌套层次（替代Consumer）</li>
<li>参数：Object，上下文对象（React.createContext()的返回值）</li>
<li>返回值：Object，上下文中的数据（由上层最近的Provider的value决定）</li>
</ul>
<h3 id="5-Callback-Hook"><a href="#5-Callback-Hook" class="headerlink" title="5.Callback Hook"></a>5.Callback Hook</h3><ul>
<li>API：React.useCallback()</li>
<li>功能：用于固定函数引用（通常用于固定回调函数）</li>
<li>目的：用于优化组件事件（组件事件是一个属性，如若传递的函数引用不固定会导致组件重新渲染而浪费效率）</li>
<li>参数1：function，需要固定的函数</li>
<li>参数2：Array，依赖项</li>
<li>返回值：function，固定引用的函数<ul>
<li>只要依赖项没有变化，函数引用就不会改变</li>
<li>依赖项没有变化， useCallback()就会忽略参数，继续返回上一次的返回值 </li>
</ul>
</li>
</ul>
<h3 id="6-Memo-Hook"><a href="#6-Memo-Hook" class="headerlink" title="6.Memo Hook"></a>6.Memo Hook</h3><ul>
<li>API：React.useMemo()</li>
<li>功能：用于稳定处理函数的结果（通常用于稳定复杂计算的结果）</li>
<li>目的：用于优化性能</li>
<li>参数1：function，处理函数</li>
<li>参数2：Array，依赖项</li>
<li>返回值：Any，处理函数的返回值<ul>
<li>只要依赖项没有变化，处理函数就不会再次调用</li>
<li>依赖项没有变化， 处理函数的返回值作为useMemo()的返回值固定不变</li>
</ul>
</li>
<li>特点：比useCallback()更加强大：<ul>
<li>useCallback()只能固定函数</li>
<li>useMemo()可以固定任意类型的数据</li>
</ul>
</li>
</ul>
<h3 id="6-Ref-Hook"><a href="#6-Ref-Hook" class="headerlink" title="6.Ref Hook"></a>6.Ref Hook</h3><ul>
<li>API：React.useRef()</li>
<li>功能：用于创建一个不可变的ref对象（通常用于固定ref引用）</li>
<li>目的：在函数组件内代替React.cteateRef()</li>
<li>参数：Any，默认值对应ref对象中current属性的值</li>
<li>返回值：Object，ref对象{current: null}</li>
<li>特点：ref对象引用不可变，但是current属性值是可变的，可用于保存任何可变值</li>
</ul>
<hr>
<h3 id="7-Reducer-Hook"><a href="#7-Reducer-Hook" class="headerlink" title="7.Reducer Hook"></a>7.Reducer Hook</h3><h4 id="1-注册"><a href="#1-注册" class="headerlink" title="1.注册"></a>1.注册</h4><ul>
<li>API：React.useReducer()</li>
<li>功能：封装Flux数据流处理模式</li>
<li>目的：在组件内只分发action声明如何处理数据，而不关注数据处理逻辑和过程</li>
<li>参数1：function，数据处理函数reducer</li>
<li>参数2：Any，数据State默认值（如果注册了第三个参数，则该默认值会作为参数而非数据默认值）</li>
<li>参数3：function，数据State默认值处理函数<ul>
<li>参数：Any，注册的第二个参数</li>
<li>返回值：Any，数据State默认值</li>
</ul>
</li>
<li>返回值：Array，数据和action分发函数[state, dispatch]</li>
</ul>
<h4 id="2-原理"><a href="#2-原理" class="headerlink" title="2.原理"></a>2.原理</h4><ul>
<li>模式：遵从Flux数据流处理模式</li>
<li>数据：仓库数据或状态state</li>
<li>action: Object，数据处理描述对象<ul>
<li>type属性：声明数据处理方式（与reducer约定对应）</li>
<li>payload属性：附加数据</li>
</ul>
</li>
<li>reducer：function，数据处理逻辑<ul>
<li>参数1：Any，数据State</li>
<li>参数2：Object，action数据处理描述对象</li>
<li>返回值：处理后的数据</li>
</ul>
</li>
<li>dispatch：function，任务分发器<ul>
<li>参数：Object，action数据处理描述对象</li>
<li>函数体：<ul>
<li>调用reducer处理函数，将数据Stae和action传入</li>
<li>得到reducer处理结果，将结果作为数据改变就数据Stae状态</li>
</ul>
</li>
</ul>
</li>
<li>useReducer：function，封装函数<ul>
<li>创建一个状态State作为数据仓库，得到一个对应的状态修改方法setState()</li>
<li>状态默认值来源于参数传入</li>
<li>定义dispatch函数，在dispatch函数内实现数据状态的改变<ul>
<li>数据处理逻辑reducer()来源于参数传入</li>
<li>数据改变方法setState()来源于创建状态时对应的改变方法</li>
<li>新数据来源于数据处理函数reducer()的调用结果</li>
<li>给数据处理函数reducer()传递的数据仓库来源于创建的状态State</li>
<li>给数据处理函数reducer()传递的action来源于外部使用dispatch时分发的action</li>
</ul>
</li>
<li>返回一个数组：<ul>
<li>第一项：数据状态State</li>
<li>第二项：dispatch函数</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h1 id="三、React-Transition-Group-动画"><a href="#三、React-Transition-Group-动画" class="headerlink" title="三、React Transition Group 动画"></a>三、React Transition Group 动画</h1><p><a href="https://reactcommunity.org/react-transition-group/" target="_blank" rel="noopener">React Transition Group文档 </a></p>
<blockquote>
<p>yarn add react-transition-group</p>
</blockquote>
<h2 id="（一）Transition"><a href="#（一）Transition" class="headerlink" title="（一）Transition"></a>（一）Transition</h2><h3 id="1-原理"><a href="#1-原理" class="headerlink" title="1.原理"></a>1.原理</h3><ul>
<li>默认情况下，Transition组件不会更改其渲染的组件的行为，它仅跟踪组件的“进入”和“退出”状态。</li>
<li>由您来赋予这些状态以意义和效果。</li>
<li>可以在组件进入或退出时为其添加样式。</li>
<li>初始状态：<ul>
<li>当in属性为false时，初始状态为exited</li>
<li>当in属性为true时，初始状态为entered</li>
</ul>
</li>
<li>进入状态：<ul>
<li>当in属性从false变化到true</li>
<li>立即执行默认状态exited</li>
<li>立即执行正在进入entering</li>
<li>延时timeout时间后，执行已完成进入entered</li>
</ul>
</li>
<li>退出状态：<ul>
<li>当in属性从true变化到false</li>
<li>立即执行默认状态entered</li>
<li>立即执行正在退出exiting</li>
<li>延时timeout时间后，执行已完成退出exited</li>
</ul>
</li>
</ul>
<h3 id="2-属性"><a href="#2-属性" class="headerlink" title="2.属性"></a>2.属性</h3><ul>
<li>in：boolean，用于决定状态</li>
<li>timeout：number，用于决定状态变化时长</li>
<li>mountOnEnter：boolean，是否延迟挂载子组件<ul>
<li>false：默认与父组件Transition同时挂载</li>
<li>true：当in指定为true时才会挂载</li>
</ul>
</li>
<li>unmountOnExit：boolean，是否在退出后卸载载子组件<ul>
<li>false：默认当状态为exited时，子组件依然挂载</li>
<li>true：当状态为exited时，子组件会被卸载</li>
</ul>
</li>
<li>appear：boolean，首次挂载是否应用过渡状态<ul>
<li>false：默认首次挂载组件没有应用过渡状态</li>
<li>true：在组件挂在后，会立即应用过渡状态</li>
</ul>
</li>
<li>其它属性</li>
<li>其它事件</li>
</ul>
<h3 id="3-状态"><a href="#3-状态" class="headerlink" title="3.状态"></a>3.状态</h3><ul>
<li>通过Transition组件的children使用一个函数，函数参数state获得实时状态<ul>
<li>‘entering’ 正在进入</li>
<li>‘entered’ 已完成进入</li>
<li>‘exiting’ 正在退出</li>
<li>‘exited’ 已完成退出</li>
</ul>
</li>
</ul>
<hr>
<h2 id="（二）CSSTransition"><a href="#（二）CSSTransition" class="headerlink" title="（二）CSSTransition"></a>（二）CSSTransition</h2><h3 id="1-原理-1"><a href="#1-原理-1" class="headerlink" title="1.原理"></a>1.原理</h3><ul>
<li>建立在Transition组件的基础上，完全继承了Transition组件的特性</li>
<li>将Transition组件过渡状态变化对应为CSSTransition根子元素设置className类</li>
<li>通过className类定义对应的类样式</li>
</ul>
<h3 id="2-属性-1"><a href="#2-属性-1" class="headerlink" title="2.属性"></a>2.属性</h3><ul>
<li>属性对应Transition组件</li>
<li>事件对应Transition组件</li>
</ul>
<h3 id="3-className类"><a href="#3-className类" class="headerlink" title="3.className类"></a>3.className类</h3><table>
<thead>
<tr>
<th align="left">Transition组件过渡状态</th>
<th align="left">CSSTransition根子元素类样式</th>
</tr>
</thead>
<tbody><tr>
<td align="left">‘entering’ 正在进入</td>
<td align="left">‘enter enter-active’</td>
</tr>
<tr>
<td align="left">‘entered’ 已完成进入</td>
<td align="left">‘enter-done’</td>
</tr>
<tr>
<td align="left">‘exiting’ 正在退出</td>
<td align="left">‘exit exit-active’</td>
</tr>
<tr>
<td align="left">‘exited’ 已完成退出</td>
<td align="left">‘exit-done’</td>
</tr>
<tr>
<td align="left">‘appear’ 首次挂载</td>
<td align="left">‘appear’</td>
</tr>
<tr>
<td align="left">‘appearing’ 首次挂载中</td>
<td align="left">‘appear appear-active’</td>
</tr>
<tr>
<td align="left">‘appeared’ 首次挂载完成</td>
<td align="left">‘appear-done enter-done’</td>
</tr>
</tbody></table>
<ul>
<li>当in属性从false变化为true时：<ul>
<li>立即添加类样式：enter（强制回流）</li>
<li>立即添加类样式：enter-active</li>
<li>延时timeout时间后，移除类样式enter、enter-active，添加类样式enter-done</li>
</ul>
</li>
<li>当in属性从true变化为false时：<ul>
<li>立即添加类样式：exit（强制回流）</li>
<li>立即添加类样式：exit-active</li>
<li>延时timeout时间后，移除类样式exit、exit-active，添加类样式exit-done</li>
</ul>
</li>
<li>使用classNames属性修改对应类样式名称<ul>
<li>字符串：添加前缀</li>
<li>对象：具体修改类样式名称</li>
</ul>
</li>
<li><a href="https://animate.style/" target="_blank" rel="noopener">与css动画库animate.css联用</a></li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">classNames=&#123;&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">   appear: <span class="string">'my-appear'</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">   appearActive: <span class="string">'my-active-appear'</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">   appearDone: <span class="string">'my-done-appear'</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">   enter: <span class="string">'my-enter'</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">   enterActive: <span class="string">'my-active-enter'</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">   enterDone: <span class="string">'my-done-enter'</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">   exit: <span class="string">'my-exit'</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">   exitActive: <span class="string">'my-active-exit'</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">   exitDone: <span class="string">'my-done-exit'</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">&#125;&#125;</span></pre></td></tr></table></figure>
<hr>
<h2 id="（三）SwitchTransition"><a href="#（三）SwitchTransition" class="headerlink" title="（三）SwitchTransition"></a>（三）SwitchTransition</h2><ul>
<li>children属性接受一个Transition或CSSTransition组件，主要实现有次序的切换<ul>
<li>Transition或CSSTransition组件不再使用in属性</li>
<li>Transition或CSSTransition组件使用key属性</li>
<li>控制Transition或CSSTransition组件根子元素的样式</li>
<li>当key值发生变化的时候，重现渲染Transition或CSSTransition组件根子元素（DOM元素）</li>
</ul>
</li>
<li>model属性控制切换模式<ul>
<li>out-in<ul>
<li>当key值发生变化的时候</li>
<li>为DOM元素添加退出样式exit、exit-active</li>
<li>退出完成后，将DOM元素移除</li>
<li>重现渲染DOM元素</li>
<li>为新DOM元素素添加进入样式enter、enter-active、enter-done</li>
</ul>
</li>
<li>in-out<ul>
<li>当key值发生变化的时候</li>
<li>重现渲染DOM元素（保留原DOM元素）</li>
<li>为DOM元素添加进入样式enter、enter-active、enter-done</li>
<li>为原DOM元素添加退出样式exit、exit-active</li>
<li>退出完成后，将原DOM元素移除</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="（四）TransitionGroup"><a href="#（四）TransitionGroup" class="headerlink" title="（四）TransitionGroup"></a>（四）TransitionGroup</h2><ul>
<li>children属性接受多个Transition或CSSTransition组件，主要实现一组（列表）动画</li>
<li><a href="https://www.npmjs.com/package/uuid" target="_blank" rel="noopener">使用uuid定义唯一的key值</a></li>
<li>当一个DOM元素移除时会应用退出类样式</li>
<li>当一个DOM元素添加时会应用进入类样式</li>
<li>appear属性：可统一控制整个列表首次挂载应用进入样式</li>
<li>component属性：控制TransitionGroup在组件树中生成的结构<ul>
<li>默认生成一个div</li>
<li>字符串：指定生成的元素，例如“ul”</li>
<li>null：不生成任何元素</li>
</ul>
</li>
</ul>
<hr>
<h1 id="四、React-Router-路由"><a href="#四、React-Router-路由" class="headerlink" title="四、React Router 路由"></a>四、React Router 路由</h1><p><a href="http://react-guide.github.io/react-router-cn/index.html" target="_blank" rel="noopener">React Router</a></p>
<p><a href="https://github.com/ReactTraining/react-router/tree/master/packages/react-router-dom#installation" target="_blank" rel="noopener">React Router Dom</a></p>
<blockquote>
<p>yarn add react-router-dom</p>
</blockquote>
<h2 id="（一）概述"><a href="#（一）概述" class="headerlink" title="（一）概述"></a>（一）概述</h2><h3 id="1-单页面应用"><a href="#1-单页面应用" class="headerlink" title="1.单页面应用"></a>1.单页面应用</h3><ul>
<li>通常只是站点的一部分（某一个功能块）</li>
<li>路由：<ul>
<li>根据不同的页面地址，展示不同的组件</li>
<li>实现无刷新地址切换</li>
</ul>
</li>
</ul>
<h3 id="2-url地址"><a href="#2-url地址" class="headerlink" title="2.url地址"></a>2.url地址</h3><ul>
<li>协议名（schema）</li>
<li>主机名（host）<ul>
<li>IP地址</li>
<li>预设值：localhost</li>
<li>域名</li>
<li>局域网电脑名称</li>
</ul>
</li>
<li>端口号（port）<ul>
<li>http：默认80</li>
<li>https：默认443</li>
</ul>
</li>
<li>路径（path）</li>
<li>地址参数（search、query）</li>
<li>哈希、锚点（hash）</li>
</ul>
<h3 id="3-路由模式"><a href="#3-路由模式" class="headerlink" title="3.路由模式"></a>3.路由模式</h3><ul>
<li>Hash Router 哈希路由<ul>
<li>url地址中hash值的改变不会导致页面的属性</li>
<li>根据hash值来确定渲染的组件</li>
<li>使用location对象的hash属性获得hash值</li>
</ul>
</li>
<li>Browser History Router 浏览器历史记录路由<ul>
<li>history历史记录使用栈stack存储</li>
<li>html5新增history API使浏览器可以改变url地址而不刷新页面<ul>
<li>history.pushState(data, title, url)向历史记录栈中添加一条url记录</li>
<li>history.replaceState(data, title, url)将当前指向的url记录替换为指定的url记录</li>
</ul>
</li>
<li>根据页面路径来确定渲染的组件</li>
</ul>
</li>
</ul>
<hr>
<h2 id="（二）路由组件"><a href="#（二）路由组件" class="headerlink" title="（二）路由组件"></a>（二）路由组件</h2><h3 id="1-Router-模式组件"><a href="#1-Router-模式组件" class="headerlink" title="1.Router 模式组件"></a>1.Router 模式组件</h3><ul>
<li>HashRouter组件，哈希路由模式</li>
<li>BrowserRouter组件，浏览器历史记录路由模式<ul>
<li>Router组件<ul>
<li>Router.Provider组件，提供上下文支持<ul>
<li>value包含三个数据对象（仅组件内部使用，且是包装过的）<ul>
<li>history</li>
<li>location</li>
<li>match</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>getUserConfirmation属性：function，阻塞器函数</li>
</ul>
</li>
</ul>
<h3 id="2-Route-规则组件"><a href="#2-Route-规则组件" class="headerlink" title="2.Route 规则组件"></a>2.Route 规则组件</h3><ul>
<li>Route组件，路由配置<ul>
<li>Router.Consumer组件，获得路由上下文<ul>
<li>Router.Provider组件，提供局部上下文</li>
</ul>
</li>
<li>path属性：<ul>
<li>string，匹配路径</li>
<li>string-pattern，匹配规则</li>
<li>array，一组匹配路径（匹配其一即可）</li>
<li>不配置path属性，任意匹配</li>
</ul>
</li>
<li>sensitive属性：boolean，是否区分大小写</li>
<li>exact属性：boolean，是否精确匹配</li>
<li>strict属性：boolean，是够严格匹配最后一个斜杠/</li>
<li>component属性：element，定义匹配后渲染的组件</li>
<li>render属性：function，定义匹配后运行的函数，渲染返回值</li>
<li>children属性<ul>
<li>React元素：只要当前Route进行了匹配，无论是否匹配成功，子元素都会渲染，并且会忽略component属性</li>
<li>function函数：<ul>
<li>参数：路由上下文</li>
<li>返回值：只要当前Route进行了匹配，无论是否匹配成功，返回值都会渲染，并且会忽略component属性</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="3-功能组件"><a href="#3-功能组件" class="headerlink" title="3.功能组件"></a>3.功能组件</h3><ul>
<li><strong>Switch组件</strong>，控制一组Route组件，只要匹配到一个即停止匹配</li>
<li><strong>withRouter高阶组件</strong>，向非路由组件中注入路由信息</li>
<li><strong>Link组件</strong>，生成一个无刷新跳转的a元素<ul>
<li>to属性：<ul>
<li>string：路径</li>
<li>object：自定义location对象，会自动解析到地址栏</li>
</ul>
</li>
<li>replace属性：boolean，是否使用replace方式跳转</li>
<li>innerRef属性：DOM，对应内部真实a元素</li>
</ul>
</li>
<li><strong>NavLink组件</strong>，强化的Link组件，添加匹配时类样式<ul>
<li>activeClassName属性：string，自定义匹配时类样式（默认active）</li>
<li>activeStyle属性：object，匹配时行间样式</li>
</ul>
</li>
<li><strong>Redirect组件</strong>，强化的Link组件，重定向（当该组件运行时直接跳转至to属性定义的地址）<ul>
<li>to属性：路径</li>
<li>push属性：是否使用push方式跳转</li>
<li>from属性：跳转条件（当匹配到from属性时才进行跳转）</li>
</ul>
</li>
</ul>
<hr>
<h2 id="（三）路由信息"><a href="#（三）路由信息" class="headerlink" title="（三）路由信息"></a>（三）路由信息</h2><h3 id="1-创建"><a href="#1-创建" class="headerlink" title="1.创建"></a>1.创建</h3><ul>
<li>Router组件会创建上下文，并注入信息</li>
<li>Route组件也会创建上下文，并注入信息</li>
</ul>
<h3 id="2-获取"><a href="#2-获取" class="headerlink" title="2.获取"></a>2.获取</h3><ul>
<li>上下文对于开发者是不可用的</li>
<li>Route组件在匹配成功后，将上下文中的信息作为属性传递给对应的组件</li>
<li>通过组件属性获得对应的路由信息<ul>
<li>props.history</li>
<li>props.location</li>
<li>props.match</li>
</ul>
</li>
</ul>
<h3 id="3-history对象"><a href="#3-history对象" class="headerlink" title="3.history对象"></a>3.history对象</h3><ul>
<li><strong>实现无刷新地址跳转</strong></li>
<li>该对象是包装过的，不是原生的window.history对象<ul>
<li>如果直接使用原生history对象，则无法支持哈希路由模式</li>
<li>原生history对象方法使用时不会有任何通知，React无法知晓地址变化，不会重现渲染组件</li>
</ul>
</li>
<li>push方法：将新的地址入栈<ul>
<li>参数1：新路径</li>
<li>参数2：附加state数据<ul>
<li>通过history.location.state获取</li>
<li>此数据依赖跳转时手动附加，如果直接访问某个地址则无法拥有状态数据，所以数据通常附带在url地址中，而不是使用此处的附加state</li>
</ul>
</li>
</ul>
</li>
<li>replace方法：将新地址替换当前地址<ul>
<li>参数1：新路径</li>
<li>参数2：附加state数据</li>
</ul>
</li>
<li>go方法</li>
<li>forward方法</li>
<li>back方法</li>
<li>listen方法：监听器<ul>
<li>参数：function，当地址变化时调用该函数（即将跳转到新页面之前）<ul>
<li>参数1：location对象，当前地址信息</li>
<li>参数2：action字符串，进入地址方式<ul>
<li>“POP” ：浏览器前进后退、history.go()、history.goBack()、history.goForward()</li>
<li>“PUSH” ：history.push()</li>
<li>“REPLACE” ：history.replace()</li>
</ul>
</li>
</ul>
</li>
<li>返回值：function，调用此函数取消监听</li>
</ul>
</li>
<li>block()方法：阻塞器<ul>
<li>参数：阻塞提示信息<ul>
<li>string</li>
<li>function<ul>
<li>参数1：location对象</li>
<li>参数2：action类型</li>
<li>返回值：string</li>
</ul>
</li>
</ul>
</li>
<li>调用getUserConfirmation()<ul>
<li>参数1：string，阻塞提示信息</li>
<li>参数2：function，是否放行<ul>
<li>放行：调用并传递true</li>
<li>阻塞：调用并传递false</li>
</ul>
</li>
</ul>
</li>
<li>返回值：function，调用此函数取消阻塞</li>
</ul>
</li>
</ul>
<h3 id="4-location"><a href="#4-location" class="headerlink" title="4.location"></a>4.location</h3><ul>
<li><strong>地址栏信息</strong></li>
<li>与history.location是同一个对象</li>
<li>hash属性：哈希值</li>
<li>pathname属性：路径</li>
<li>search属性：search数据</li>
<li>state属性：附加状态数据</li>
<li><a href="https://github.com/sindresorhus/query-string#readme" target="_blank" rel="noopener">使用query-string库解析字符串</a></li>
</ul>
<h3 id="5-match"><a href="#5-match" class="headerlink" title="5.match"></a>5.match</h3><ul>
<li><strong>路由匹配信息</strong></li>
<li>path属性：匹配规则</li>
<li>url属性：真实url地址中匹配到的部分</li>
<li>isExact属性：是否是精确匹配（指的是匹配结果是否精确，而非匹配方式是否精确，与Route组件定义exact属性无关）</li>
<li>params属性：对应string-pattern匹配规则中的数据</li>
<li><a href="https://github.com/pillarjs/path-to-regexp#readme" target="_blank" rel="noopener">path-to-regexp库实现string-pattern匹配规则</a></li>
</ul>
<hr>
<h2 id="（四）路由应用"><a href="#（四）路由应用" class="headerlink" title="（四）路由应用"></a>（四）路由应用</h2><h3 id="1-嵌套路由"><a href="#1-嵌套路由" class="headerlink" title="1.嵌套路由"></a>1.嵌套路由</h3><ul>
<li>通过父组件传递的属性location.url简化内层路由path</li>
<li>使用配置对象简化路由path</li>
</ul>
<h3 id="2-权限保护"><a href="#2-权限保护" class="headerlink" title="2.权限保护"></a>2.权限保护</h3><ul>
<li>封装一个自定义路由ProtectedRoute，使用方法与Route一样</li>
<li>返回一个Route组件</li>
<li>将component、render、children除外的属性传递给Route</li>
<li>Route组件使用render函数</li>
<li>在函数内部进行授权处理<ul>
<li>有权，则render直接返回component进行渲染</li>
<li>无权，则使用Redirect组件进行重定向</li>
</ul>
</li>
<li>在Redirect组件进行重定向进行重定向的时候，附带当前地址</li>
<li>在完成登录后，获取附带数据中的地址进行跳回</li>
<li>如果附带数据中没有跳转地址，则直接跳转至某个页面（通常是首页）</li>
</ul>
<h3 id="3-导航守卫"><a href="#3-导航守卫" class="headerlink" title="3.导航守卫"></a>3.导航守卫</h3><ul>
<li>离开一个页面，进入另一个页面时，触发的事件</li>
<li>使用history.listen方法添加一个监听器<ul>
<li>参数：function，监听器函数<ul>
<li>监听器的参数可以获得新location信息和action类型</li>
<li>监听器外部history.location获得旧的location信息</li>
</ul>
</li>
<li>返回值：function，卸载一个监听器</li>
</ul>
</li>
<li>使用history.block()方法添加一个阻塞器<ul>
<li>传递阻塞提示信息</li>
<li>调用阻塞器函数，并传递msg阻塞消息和callback放行函数</li>
<li>调用放行函数，传递true放行，传递false阻塞</li>
</ul>
</li>
</ul>
<h3 id="4-路由动画"><a href="#4-路由动画" class="headerlink" title="4.路由动画"></a>4.路由动画</h3><h3 id="5-滚动条复位"><a href="#5-滚动条复位" class="headerlink" title="5.滚动条复位"></a>5.滚动条复位</h3><h3 id="6-阻止跳转"><a href="#6-阻止跳转" class="headerlink" title="6.阻止跳转"></a>6.阻止跳转</h3><hr>
<h1 id="五、Redux-数据管理"><a href="#五、Redux-数据管理" class="headerlink" title="五、Redux 数据管理"></a>五、Redux 数据管理</h1><p><a href="https://redux.js.org/api/api-reference" target="_blank" rel="noopener">redux官方文档</a></p>
<blockquote>
<p>yard add redux</p>
</blockquote>
<h2 id="（一）Redux-核心"><a href="#（一）Redux-核心" class="headerlink" title="（一）Redux 核心"></a>（一）Redux 核心</h2><h3 id="1-MVC解决方案"><a href="#1-MVC解决方案" class="headerlink" title="1.MVC解决方案"></a>1.MVC解决方案</h3><ul>
<li>它是一个UI的解决方案，用于降低UI复杂度，以及UI关联的数据复杂度</li>
<li><strong>传统的服务端MVC</strong><ul>
<li>服务端响应一个完整的HTML页面</li>
<li>该HTML中包含页面所需要的数据</li>
<li>浏览器仅仅承担渲染的作用<img src="./MVC.png"></li>
</ul>
</li>
<li>Controller 处理请求，组装这次请求所需要的数据</li>
<li>Model 处理数据用于UI渲染的数据模型</li>
<li>View 试图，将数据模型组装到页面中</li>
<li><font color=red>不适用于前端（用户场景太多，控制太复杂）</font></li>
</ul>
<h3 id="2-FLUX解决方案"><a href="#2-FLUX解决方案" class="headerlink" title="2.FLUX解决方案"></a>2.FLUX解决方案</h3><ul>
<li>facebook提出的数据解决方案，他的最大历史意义在于它引入了action概念</li>
<li>action是一个普通的对象，用于描述干什么，action.type必须是一个String类型</li>
<li>store数据仓库，用于存储数据</li>
</ul>
<h3 id="3-Redux解决方案"><a href="#3-Redux解决方案" class="headerlink" title="3.Redux解决方案"></a>3.Redux解决方案</h3><ul>
<li>在flux基础上引入reducer<img src="./redux.png"></li>
<li>自定义reducer数据处理程序<ul>
<li>类型：function</li>
<li>参数1：旧state</li>
<li>参数2：action</li>
<li>返回值：新state</li>
</ul>
</li>
<li>自定义action数据处理描述<ul>
<li>类型：object</li>
<li>type属性：描述</li>
<li>payload属性：附带数据</li>
</ul>
</li>
<li>创建数据仓库store<ul>
<li>从redux引入createStore  </li>
<li>store = createStore(reducer, state)创建数据仓库</li>
</ul>
</li>
<li>分发action：store.dispatch(action)</li>
<li>获取数据：store.getState()</li>
</ul>
<h3 id="4-action"><a href="#4-action" class="headerlink" title="4.action"></a>4.action</h3><ul>
<li>action必须是一个plain-object(平面对象，它的<strong>proto</strong>指向Object.prototype)</li>
<li>action必须有一个type属性（any类型）<ul>
<li>大中型项目中避免硬编码, 可以使用type文件形式的样板代码</li>
</ul>
</li>
<li>action可以有一个payload属性（附加数据）</li>
<li>为了方便传递action，通常会使用action创建函数来创建action<ul>
<li>创建函数应该是一个无副作用的纯函数，该函数返回一个action对象</li>
</ul>
</li>
<li>为了方便利用action创建函数来分发，可以使用 bindActionCreators<ul>
<li>bindActionCreators用于增强action的功能，不仅可以创建action，并且在创建action后自动完成分发</li>
<li>bindActionCreators第一个参数接受一个对象，对象的属性对应action创建函数</li>
<li>bindActionCreators第二个参数接受一个dispatch，用于指定是哪一个用dispatch来完成分发</li>
<li>bindActionCreators返回一个对象，对象方法与接受的第一个参数对象相同，调用该对象的方法即完成使用对应的action进行分发</li>
</ul>
</li>
</ul>
<h3 id="5-reducer"><a href="#5-reducer" class="headerlink" title="5.reducer"></a>5.reducer</h3><ul>
<li>reducer必须为一个纯函数，用于处理对应的action触发时如何处理数据</li>
<li>reducer调用：<ul>
<li>store.dispatch分发的时候</li>
<li>createStore初始化仓库的时候</li>
<li>初始化仓库时可以不使用默认state，而是在reducer中给一个默认值</li>
</ul>
</li>
<li>reducer内部通常使用switch来判断action.type</li>
<li>通常一个工程只有一个store, 一个store只有一个reduce<ul>
<li>为了方便管理，通常将reducer放到单独的文件中</li>
<li>在大中型项目中，操作和结构都比较复杂，需要对reducer进行细分，每一个状态对应一个处理函数reducer</li>
<li>最用将细分的reducer进行合并，使用创建对象的形式执行处理函数，并单独传递对应的数据</li>
<li>combineReducers就是将多个细分的reducer进行合并成一个reducer，用于创建store<ul>
<li>combineReducers参数接受一个对象，对象属性对应细分的reducer</li>
<li>combineReducers返回一个最终的reducer</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="6-store"><a href="#6-store" class="headerlink" title="6.store"></a>6.store</h3><ul>
<li>通过createStore创建，用于保存数据</li>
<li>dispathch方法：分发action</li>
<li>getState方法：获取仓库数据</li>
<li>replaceReducer方法：替换数据处理程序reducer</li>
<li>subscribe方法：数据变化监听器（返回一个函数用于取消监听）</li>
</ul>
<h3 id="7-redux-actions"><a href="#7-redux-actions" class="headerlink" title="7.redux-actions"></a>7.redux-actions</h3><p><a href="https://redux-actions.js.org/" target="_blank" rel="noopener">redux-actions 官方文档</a></p>
<blockquote>
<p>yarn add redux-actions</p>
</blockquote>
<ul>
<li><p><strong>createAction方法</strong>：创建一个action创建函数</p>
<ul>
<li>参数1：action.type</li>
<li>参数2：payload处理函数<ul>
<li>参数：action创建函数传递的参数</li>
<li>返回值：payload的值</li>
</ul>
</li>
<li>返回值：一个对应的action创建函数</li>
</ul>
</li>
<li><p><strong>createActions方法</strong>：创建一组action创建函数</p>
<ul>
<li>参数：object，action描述对象<ul>
<li>属性名：action.type（遵循大写、下划线分割）</li>
<li>属性值：payload处理函数（不需要payload则设置为null）</li>
</ul>
</li>
<li>返回值：object，对应的action创建函数<ul>
<li>属性名：对应action创建函数名（转换为小驼峰命名）</li>
<li>属性值：对应action创建函数</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>handleAction方法</strong>：创建处理单个action类型的reducer函数</p>
<ul>
<li>参数1：action.type（支持action创建函数名，重写了toString）</li>
<li>参数2：针对action.type匹配处理函数</li>
<li>参数3：state默认值</li>
</ul>
</li>
<li><p><strong>handleAction方法</strong>：创建处理多个action类型的reducer函数</p>
<ul>
<li>参数：object，映射规则<ul>
<li>属性名：action.type（遵循大写、下划线分割）</li>
<li>属性值：针对action.type匹配处理函数</li>
</ul>
</li>
<li>返回值：function，reducer处理函数</li>
</ul>
</li>
<li><p><strong>combineActions方法</strong>：用于配合createActions和handleActions，将多个action创建函数合并成一个，对应一个处理函数reducer</p>
<ul>
<li>参数：需要匹配的action创建函数</li>
<li>返回值：一个合并的函数</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getActions = createActions(&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  INCREASE: <span class="function"><span class="params">()</span> =&gt;</span> <span class="number">1</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">  DECREASE: <span class="function"><span class="params">()</span> =&gt;</span> <span class="number">-1</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">  ADD: <span class="function"><span class="params">n</span> =&gt;</span> n,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123;increase, decrease add&#125; = getActions</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> handleActions(&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">  [combineActions(increse, decrease, add)]: <span class="function">(<span class="params">state, &#123;type, payload&#125;</span>) =&gt;</span> state + payload</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>
<hr>
<h2 id="（二）Middleware-中间件"><a href="#（二）Middleware-中间件" class="headerlink" title="（二）Middleware 中间件"></a>（二）Middleware 中间件</h2><h3 id="1-自定义中间件"><a href="#1-自定义中间件" class="headerlink" title="1.自定义中间件"></a>1.自定义中间件</h3><h4 id="（1）原理"><a href="#（1）原理" class="headerlink" title="（1）原理"></a>（1）原理</h4><ul>
<li>更改dispatch函数<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = createStore(reducer)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> dispatch = store.dispatch</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加一个中间件1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">store.dispatch = <span class="function">(<span class="params">action</span>) =&gt;</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">  store.getState()<span class="comment">//旧数据</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">  action<span class="comment">//action</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">  dispatch()<span class="comment">//运行原有功能</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">  store.getState()<span class="comment">//新数据</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加一个中间件2</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">dispatch = store.dispatch</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">store.dispatch = <span class="function">(<span class="params">action</span>) =&gt;</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">//中间件功能</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">  dispatch()<span class="comment">//运行中间件1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">//中间件功能</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h4 id="（2）中间件函数"><a href="#（2）中间件函数" class="headerlink" title="（2）中间件函数"></a>（2）中间件函数</h4></li>
<li>中间件是一个函数<ul>
<li>参数：store仓库</li>
<li>返回值：dispatch创建函数<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = createStore(reducer)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//中间件1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">middleware</span>(<span class="params">store</span>)</span>&#123;<span class="comment">//得到仓库</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">nextDispatch</span>) =&gt;</span> &#123;<span class="comment">//得到下一个中间件的dispatch</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">action</span>) =&gt;</span> &#123;<span class="comment">//得到action</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">      <span class="comment">//中间件功能</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">      nextDispatch(action)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">      <span class="comment">//中间件功能</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> middleware = <span class="function"><span class="params">store</span> =&gt;</span> <span class="function"><span class="params">nextDispatch</span> =&gt;</span> <span class="function"><span class="params">action</span> =&gt;</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">//中间件功能</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">  nextDispatch(action)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">//中间件功能</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h4 id="（3）applyMiddleWare-应用中间件函数"><a href="#（3）applyMiddleWare-应用中间件函数" class="headerlink" title="（3）applyMiddleWare() 应用中间件函数"></a>（3）applyMiddleWare() 应用中间件函数</h4><ul>
<li>参数：中间件函数</li>
<li>返回值：用作createStore(reducer, applyMiddleWare(中间件))的第二或第三个参数</li>
<li>应用的中间件会在创建store后运行<img src="./Middleware.png">
</li>
</ul>
<hr>
<h3 id="2-redux-logger-日志记录"><a href="#2-redux-logger-日志记录" class="headerlink" title="2.redux-logger 日志记录"></a>2.redux-logger 日志记录</h3><p><a href="https://github.com/LogRocket/redux-logger#readme" target="_blank" rel="noopener">redux-logger 日志记录</a></p>
<blockquote>
<p>yard add redux-logger</p>
</blockquote>
<ul>
<li>打印日志记录</li>
<li>createLogger支持自定义日志记录打印<ul>
<li>collapsed: 日志是否折叠</li>
<li>duration：是否打印时间</li>
<li>predicate: 自定义处理函数</li>
</ul>
</li>
<li>logger中间件应放置于最后</li>
</ul>
<h3 id="3-redux-thunk-副作用处理"><a href="#3-redux-thunk-副作用处理" class="headerlink" title="3.redux-thunk 副作用处理"></a>3.redux-thunk 副作用处理</h3><p><a href="https://github.com/reduxjs/redux-thunk/redux-logger#readme" target="_blank" rel="noopener">redux-thunk 副作用处理</a></p>
<blockquote>
<p>yard add redux-thunk</p>
</blockquote>
<ul>
<li>允许action是一个带有副作用的函数</li>
<li>当action是一个函数被分发时，thunk会阻止action继续向后提交<ul>
<li>thunk会向函数中传递三个参数<ul>
<li>dispatch：来自于store.dispatch</li>
<li>getState: 来自于store.getState</li>
<li>extra: 来自于注册thunk时传递的额外参数（withExtraArgument）</li>
</ul>
</li>
</ul>
</li>
<li>logger中间件应放置于最前</li>
</ul>
<h3 id="4-redux-promise-副作用处理"><a href="#4-redux-promise-副作用处理" class="headerlink" title="4.redux-promise 副作用处理"></a>4.redux-promise 副作用处理</h3><p><a href="https://github.com/redux-utilities/redux-promise" target="_blank" rel="noopener">redux-promise 副作用处理</a></p>
<blockquote>
<p>yard add redux-promise</p>
</blockquote>
<ul>
<li>允许action或action.payload是一个promise对象</li>
<li>当action是一个promise对象时，会等待promise完成，将promise结果作为action进行触发</li>
<li>当action.payload是一个promise对象时，会等待promise完成，将promise结果作为payload进行触发</li>
<li>promise中使用resolve来触发action</li>
</ul>
<h3 id="5-redux-saga-副作用处理"><a href="#5-redux-saga-副作用处理" class="headerlink" title="5.redux-saga 副作用处理"></a>5.redux-saga 副作用处理</h3><p><a href="https://redux-saga-in-chinese.js.org/" target="_blank" rel="noopener">redux-saga 副作用处理</a></p>
<blockquote>
<p>yard add redux-saga</p>
</blockquote>
<img src="./saga.png">

<table>
<thead>
<tr>
<th align="left">saga指令</th>
<th align="left">指令功能</th>
<th align="left">指令参数</th>
<th align="left">yield结果</th>
<th align="left">是否阻塞</th>
<th align="left">特点</th>
</tr>
</thead>
<tbody><tr>
<td align="left">all()</td>
<td align="left">合并多个任务</td>
<td align="left">array：生成器集合</td>
<td align="left">/</td>
<td align="left">阻塞</td>
<td align="left">等待运行所有生成器运行结束</td>
</tr>
<tr>
<td align="left">race()</td>
<td align="left">多个任务竞赛</td>
<td align="left">array：生成器集合</td>
<td align="left">/</td>
<td align="left">阻塞</td>
<td align="left">等待第一个结束的生成器运行结束</td>
</tr>
<tr>
<td align="left">take()</td>
<td align="left">监听action触发</td>
<td align="left">action.type</td>
<td align="left">action对象</td>
<td align="left">阻塞</td>
<td align="left">只监听1次</td>
</tr>
<tr>
<td align="left">takeEvery()</td>
<td align="left">监听action触发</td>
<td align="left">action.type、callback处理程序</td>
<td align="left">/</td>
<td align="left">无阻塞</td>
<td align="left">持续监听，不断开启新任务</td>
</tr>
<tr>
<td align="left">takeLastest()</td>
<td align="left">监听action触发</td>
<td align="left">action.type、callback处理程序</td>
<td align="left">/</td>
<td align="left">无阻塞</td>
<td align="left">持续监听，自动取消之前的任务</td>
</tr>
<tr>
<td align="left">delay()</td>
<td align="left">延时</td>
<td align="left">number：timeout</td>
<td align="left">/</td>
<td align="left">阻塞</td>
<td align="left">/</td>
</tr>
<tr>
<td align="left">put()</td>
<td align="left">触发action</td>
<td align="left">object：action对象</td>
<td align="left">/</td>
<td align="left">无阻塞</td>
<td align="left">/</td>
</tr>
<tr>
<td align="left">select</td>
<td align="left">获取仓库数据state</td>
<td align="left">function：数据筛选函数</td>
<td align="left">仓库数据state</td>
<td align="left">无阻塞</td>
<td align="left">/</td>
</tr>
<tr>
<td align="left">call()</td>
<td align="left">调用异步函数</td>
<td align="left">异步函数、依赖参数</td>
<td align="left">函数调用结果</td>
<td align="left">可能阻塞</td>
<td align="left">如果是promise会阻塞</td>
</tr>
<tr>
<td align="left">apply()</td>
<td align="left">调用异步函数</td>
<td align="left">this指向、异步函数、依赖参数</td>
<td align="left">函数调用结果</td>
<td align="left">可能阻塞</td>
<td align="left">如果是promise会阻塞</td>
</tr>
<tr>
<td align="left">cps()</td>
<td align="left">调用异步函数</td>
<td align="left">异步函数、依赖参数</td>
<td align="left">函数调用结果</td>
<td align="left">可能阻塞</td>
<td align="left">针对回调模式的异步</td>
</tr>
<tr>
<td align="left">promise对象</td>
<td align="left">等待promise完成</td>
<td align="left">/</td>
<td align="left">promise结果</td>
<td align="left">阻塞</td>
<td align="left">不推荐，应统一使用指令</td>
</tr>
<tr>
<td align="left">fork()</td>
<td align="left">任务分支</td>
<td align="left">生成器函数</td>
<td align="left">Task对象</td>
<td align="left">无阻塞</td>
<td align="left">/</td>
</tr>
<tr>
<td align="left">cancel()</td>
<td align="left">取消一个或多个任务</td>
<td align="left">Task对象</td>
<td align="left">Task对象</td>
<td align="left">无阻塞</td>
<td align="left">/</td>
</tr>
<tr>
<td align="left">cancelled()</td>
<td align="left">当前任务是否被取消</td>
<td align="left">/</td>
<td align="left">boolean</td>
<td align="left">无阻塞</td>
<td align="left">/</td>
</tr>
</tbody></table>
<hr>
<h2 id="（三）React-Redux-连接redux和react"><a href="#（三）React-Redux-连接redux和react" class="headerlink" title="（三）React-Redux 连接redux和react"></a>（三）React-Redux 连接redux和react</h2><p><a href="https://www.redux.org.cn/docs/react-redux/" target="_blank" rel="noopener">连接redux和react</a></p>
<blockquote>
<p>yarn add react-redux</p>
</blockquote>
<h3 id="1-Provider组件"><a href="#1-Provider组件" class="headerlink" title="1.Provider组件"></a>1.Provider组件</h3><ul>
<li>将redux的store仓库放到一个上下文中</li>
<li>通过store属性提供store仓库</li>
</ul>
<h3 id="2-connect函数"><a href="#2-connect函数" class="headerlink" title="2.connect函数"></a>2.connect函数</h3><ul>
<li>参数1：属性映射函数 mapStateToProps<ul>
<li>参数：传入整个仓库数据state</li>
<li>返回值：映射的数据对象</li>
</ul>
</li>
<li>参数2：事件映射函数 mapDispatchToProps<ul>
<li>参数：会传入dispatch</li>
<li>返回值：映射的事件处理程序对象</li>
</ul>
</li>
<li>返回值：高阶组件<ul>
<li>参数：需要连接的展示组件</li>
<li>返回值：提供数据的容器组件</li>
</ul>
</li>
<li><strong>细节：</strong><ul>
<li>connect的前两个参数是可选的，不要相应映射的时候传递null</li>
<li>connect的第二个参数可以是一个对象，每个属性是一个action创建函数</li>
<li>connect的第二个参数默认不传递，那么链接的组件默认会得到一个dispatch属性，有能力去自己触发action</li>
<li>connnect的后两个参数是可选的，mergeProps用于将要传递的属性进一步处理，options用于配置自定义处理</li>
</ul>
</li>
</ul>
<h3 id="3-connectAdvanced"><a href="#3-connectAdvanced" class="headerlink" title="3.connectAdvanced"></a>3.connectAdvanced</h3><ul>
<li>用于统一处理需要传递的属性</li>
<li>参数：function<ul>
<li>参数：dispatch</li>
<li>返回值：function<ul>
<li>参数：state, props</li>
<li>返回值：object此对象的属性用于传递</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="4-createProvider"><a href="#4-createProvider" class="headerlink" title="4.createProvider"></a>4.createProvider</h3><ul>
<li>通过唯一的key创建一个上下文</li>
<li>通过connect中options的storeKey来确定要使用的上下文</li>
</ul>
<hr>
<h2 id="（四）Connected-React-Router-连接redux和react-router"><a href="#（四）Connected-React-Router-连接redux和react-router" class="headerlink" title="（四）Connected-React-Router 连接redux和react-router"></a>（四）Connected-React-Router 连接redux和react-router</h2><p><a href="https://github.com/supasate/connected-react-router#readme" target="_blank" rel="noopener">连接redux和react-router</a></p>
<blockquote>
<p>yarn add connected-react-router<br>yarn add history</p>
</blockquote>
<h3 id="1-connectRouter方法"><a href="#1-connectRouter方法" class="headerlink" title="1.connectRouter方法"></a>1.connectRouter方法</h3><ul>
<li>用于创建一个reducer</li>
<li>参数：需要一个history对象</li>
<li>返回值：一个reducer</li>
<li>在combineReducers中使用router对应connectRouter创建的reducer</li>
</ul>
<h3 id="2-routerMiddleware方法"><a href="#2-routerMiddleware方法" class="headerlink" title="2.routerMiddleware方法"></a>2.routerMiddleware方法</h3><ul>
<li>用于创建一个中间件</li>
<li>参数：需要一个history对象</li>
<li>返回值：一个Middleware</li>
<li>在applyMiddleware中使用率先使用此中间件（位于第一个）</li>
</ul>
<h3 id="3-ConectedRouter组件"><a href="#3-ConectedRouter组件" class="headerlink" title="3.ConectedRouter组件"></a>3.ConectedRouter组件</h3><ul>
<li>用于创建一个路由上下文</li>
<li>替代BrowserRouter和HashRouter</li>
<li>上下文中使用react-router路由跳转的时候会自动触发action</li>
<li>若使用Connected-React-Router中的跳转，则默认得到的是action创建函数<ul>
<li>push()：创建一个action</li>
<li>repalce()：创建一个action</li>
</ul>
</li>
<li>使用react-redux中connect进行链接<ul>
<li>通过事件映射dispatch触发action进行跳转</li>
</ul>
</li>
</ul>
<hr>
<h1 id="六、Dva-js"><a href="#六、Dva-js" class="headerlink" title="六、Dva-js"></a>六、Dva-js</h1><img src="./dva.png">

<p><a href="https://dvajs.com/" target="_blank" rel="noopener">dva官方文档</a></p>
<blockquote>
<p>yarn add dva</p>
</blockquote>
<ul>
<li>整合：<ul>
<li>react</li>
<li>react-dom</li>
<li>redux</li>
<li>redux-saga</li>
<li>react-redux</li>
<li>connected-react-router</li>
</ul>
</li>
</ul>
<h3 id="1-配置部分-dvaObj"><a href="#1-配置部分-dvaObj" class="headerlink" title="1.配置部分 dvaObj"></a>1.配置部分 dvaObj</h3><ul>
<li>dva()创建一个dva对象<ul>
<li>参数：object<ul>
<li>history：配置history对象</li>
<li>initialState: 配置创建仓库时默认数据</li>
<li>onError: 全局错误捕捉函数，传递错误信息error和dispatch函数</li>
<li>onAction：配置中间件（中间件对象或数组）</li>
<li>onStateChange: 仓库数据状态变化监听函数，传递最新状态</li>
<li>onReducer: 传递一个reducer，返回一个reducer函数，在每个reducer即将运行前触发</li>
<li>onEffect: 默认effect包装函数替换方案</li>
<li>extraReducers：额外附加的reducer，一个对象，每个方法是一个reducer</li>
<li>extraEnhancers: 默认createStore方法的增强方案，一个数组，每一项是一个函数</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2-组件部分-react"><a href="#2-组件部分-react" class="headerlink" title="2.组件部分 react"></a>2.组件部分 react</h3><ul>
<li>dvaObj.router()定义渲染内容<ul>
<li>参数：function<ul>
<li>参数1：dvaObj</li>
<li>参数2：history</li>
</ul>
</li>
<li>返回值：渲染内容</li>
</ul>
</li>
<li>dvaObj.start()定义项目启动<ul>
<li>参数：css选择器（document.querySelector）</li>
</ul>
</li>
</ul>
<h3 id="3-数据部分-redux"><a href="#3-数据部分-redux" class="headerlink" title="3.数据部分 redux"></a>3.数据部分 redux</h3><ul>
<li>dvaObj.model()定义渲染内容<ul>
<li>参数：object<ul>
<li>namespace</li>
<li>state</li>
<li>reducers</li>
<li>effects</li>
<li>subscriptions</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="4-路由部分-router"><a href="#4-路由部分-router" class="headerlink" title="4.路由部分 router"></a>4.路由部分 router</h3><ul>
<li>相关的导出路径 ‘dva/router’</li>
<li>默认完成connectRouter：传入history, 配置reducer</li>
<li>默认完成routerMiddleware：传入history, 配置redux中间件</li>
<li>自行处理ConnectedRouter：传入history, 配置router上下文<ul>
<li>在创建dva对象时配置history</li>
<li>在调用router时候，dva默认会给routerConfig函数传递dva对象和history对象</li>
<li>在使用routerRedux的ConnectedRouter组件替代BrowserRouter或HashRouter并传递一个history属性</li>
</ul>
</li>
</ul>
<h3 id="5-插件部分-use"><a href="#5-插件部分-use" class="headerlink" title="5.插件部分 use"></a>5.插件部分 use</h3><ul>
<li>dvaObj.use()使用插件</li>
</ul>
<hr>
<h1 id="七、Umi-js"><a href="#七、Umi-js" class="headerlink" title="七、Umi-js"></a>七、Umi-js</h1><p><a href="https://umijs.org/zh-CN" target="_blank" rel="noopener">umi.js官方文档</a></p>
<blockquote>
<p>yarn global add umi</p>
</blockquote>
<h2 id="（一）路由"><a href="#（一）路由" class="headerlink" title="（一）路由"></a>（一）路由</h2><h3 id="1-约定式路由"><a href="#1-约定式路由" class="headerlink" title="1.约定式路由"></a>1.约定式路由</h3><h4 id="（1）匹配"><a href="#（1）匹配" class="headerlink" title="（1）匹配"></a>（1）匹配</h4><ul>
<li>umi约定，使用文件名及文件路径匹配对应的路由</li>
<li>pages目录用于存放页面<ul>
<li>root/pages</li>
<li>root/src/pages</li>
</ul>
</li>
<li>嵌套路由：使用属性中的children来定义内容位置<ul>
<li>全局嵌套<ul>
<li>root/layouts/index.js</li>
<li>root/src/layout/index.js</li>
</ul>
</li>
<li>局部嵌套<ul>
<li>root/pages/_layout.js</li>
<li>root/src/pages/_layout.js</li>
</ul>
</li>
</ul>
</li>
<li>404路由：只有在生产模式启用<ul>
<li>root/pages/404.js</li>
<li>root/src/pages/404.js </li>
</ul>
</li>
<li>动态路由：使用$ + name对应string-pattern规则<ul>
<li>root/pages/$id.js</li>
<li>root/src/pages/$name/$id.js</li>
</ul>
</li>
</ul>
<h4 id="（2）跳转"><a href="#（2）跳转" class="headerlink" title="（2）跳转"></a>（2）跳转</h4><ul>
<li>链接跳转<blockquote>
<p>import Link from ‘umi/link’<br>import NavLink from ‘umi/navlink’</p>
</blockquote>
<ul>
<li>使用Link组件：相当于react-router-dom中Link</li>
<li>使用NavLink组件：相当于react-router-dom中NavLink</li>
</ul>
</li>
<li>代码跳转<blockquote>
<p>import router from ‘umi/router’ </p>
</blockquote>
<ul>
<li>使用router对象<ul>
<li>go方法</li>
<li>goBack方法</li>
<li>goForward方法</li>
<li>push方法</li>
<li>replace方法</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="（3）路由信息"><a href="#（3）路由信息" class="headerlink" title="（3）路由信息"></a>（3）路由信息</h4><ul>
<li>pages、layout目录下的组件：<ul>
<li>使用属性props来获得：<ul>
<li>match<ul>
<li>params属性对应string-pattern规则参数</li>
</ul>
</li>
<li>history</li>
<li>location<ul>
<li>query属性已经使用query-string封装成对象</li>
</ul>
</li>
<li>route</li>
</ul>
</li>
</ul>
</li>
<li>非pages、layout目录下的组件：<ul>
<li>使用withRouter高阶组件<blockquote>
<p>import withRouter from ‘umi/withRouter’</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h4 id="（4）额外属性配置"><a href="#（4）额外属性配置" class="headerlink" title="（4）额外属性配置"></a>（4）额外属性配置</h4><ul>
<li>使用文档注释：遵循YAML格式，且必须配置于最顶部</li>
<li>键值对格式：不使用引号，且冒号后严格使用空格</li>
<li>数组项使用-并缩进：不使用中括号，且严格使用空格缩进，不支持tab缩进</li>
</ul>
<h3 id="2-配置式路由"><a href="#2-配置式路由" class="headerlink" title="2.配置式路由"></a>2.配置式路由</h3><ul>
<li>优先级高于约定式（一旦配置，约定式全部失效）</li>
<li>配置根目录文件：（其中之一）<ul>
<li>root/.umirc.js</li>
<li>root/config/config.js</li>
</ul>
</li>
<li>配置文件默认导出一个对象，配置route属性，类型是一个数组<ul>
<li>每一项就是一条匹配规则，类型是一个对象<ul>
<li>path：匹配路径</li>
<li>exact：是否精确匹配，默认true</li>
<li>component：渲染组件路径，相对于pages</li>
<li>routes：路由嵌套，一个数组，配置子路由</li>
<li>Routes：预处理<ul>
<li>一个数组，数组项为预处理的高阶组件路径，相对于根目录</li>
<li>渲染第一项，如果使用了children属性：<ul>
<li>将component配置组件作为children属性，传递给数组最后一项</li>
<li>每一项倒序作为children属性依次向前传递，最终渲染第一项</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="（二）数据"><a href="#（二）数据" class="headerlink" title="（二）数据"></a>（二）数据</h2><h3 id="1-dva管理redux数据"><a href="#1-dva管理redux数据" class="headerlink" title="1.dva管理redux数据"></a>1.dva管理redux数据</h3><blockquote>
<p>import {connect} from ‘umi’</p>
</blockquote>
<ul>
<li>全局定义：<ul>
<li>root/models/namespace.js</li>
<li>root/src/models/namespace.js</li>
</ul>
</li>
<li>局部定义<ul>
<li>root/pages/models/namespace.js</li>
<li>root/src/pages/models/namespace.js</li>
<li>root/src/pages/model.js</li>
</ul>
</li>
<li>文件名即为namespace</li>
</ul>
<h3 id="2-代理服务器解决开发中的跨域"><a href="#2-代理服务器解决开发中的跨域" class="headerlink" title="2.代理服务器解决开发中的跨域"></a>2.代理服务器解决开发中的跨域</h3><ul>
<li>配置.umirc.js文件中proxy对象<ul>
<li>属性名：访问的地址</li>
<li>属性值：object<ul>
<li>target：转发的地址</li>
<li>changeOrgin：是否修改源</li>
</ul>
</li>
</ul>
</li>
<li>让跨域发生在代理服务器与服务器中</li>
</ul>
<h3 id="3-协同开发中数据模拟"><a href="#3-协同开发中数据模拟" class="headerlink" title="3.协同开发中数据模拟"></a>3.协同开发中数据模拟</h3><ul>
<li>使用mock模块<ul>
<li>root/mock/data.js</li>
<li>root/src/pages/_mock.js</li>
</ul>
</li>
<li>默认导出一个对象<ul>
<li>属性名：string, method + url</li>
<li>属性值：any, 模拟数据</li>
</ul>
</li>
</ul>
<hr>
<h2 id="（三）样式"><a href="#（三）样式" class="headerlink" title="（三）样式"></a>（三）样式</h2><h3 id="1-组件私有样式"><a href="#1-组件私有样式" class="headerlink" title="1.组件私有样式"></a>1.组件私有样式</h3><ul>
<li>与组件同目录</li>
<li>导入css时，会通过css-mudle处理为一个对象，从对象属性获得类样式</li>
</ul>
<h3 id="2-局部样式"><a href="#2-局部样式" class="headerlink" title="2.局部样式"></a>2.局部样式</h3><ul>
<li>root/src/assets/css/style.css</li>
<li>导入css时，会通过css-mudle处理为一个对象，从对象属性获得类样式</li>
</ul>
<h3 id="3-全局样式"><a href="#3-全局样式" class="headerlink" title="3.全局样式"></a>3.全局样式</h3><ul>
<li>root/src/global.css</li>
<li>导入css时，不会会通过css-mudle处理，直接使用样式</li>
</ul>
<hr>
<h2 id="（四）配置"><a href="#（四）配置" class="headerlink" title="（四）配置"></a>（四）配置</h2><h2 id="（五）脚手架"><a href="#（五）脚手架" class="headerlink" title="（五）脚手架"></a>（五）脚手架</h2><blockquote>
<p>yarn create umi</p>
</blockquote>
<hr>
<h1 id="八、antDesign"><a href="#八、antDesign" class="headerlink" title="八、antDesign"></a>八、antDesign</h1><p><a href="https://ant.design/index-cn" target="_blank" rel="noopener">antDesign官方文档</a></p>

      
      <!-- 打赏 -->
      
    </div>
    <footer class="article-footer">
      <a data-url="https://huafuhub.github.io/blog/2020/11/09/REACTa/" data-id="ckhacid6a000t74w147kwc92r"
        class="article-share-link">分享</a>
      
    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-JWTa" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/blog/2020/11/09/JWTa/"
    >JWT原理详解</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/blog/2020/11/09/JWTa/" class="article-date">
  <time datetime="2020-11-09T08:28:11.000Z" itemprop="datePublished">2020-11-09</time>
</a>
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      


      

      
      <p>随着前后端分离的发展，以及数据中心的建立，越来越多的公司会创建一个中心服务器，服务于各种产品线。</p>
<p>而这些产品线上的产品，它们可能有着各种终端设备，包括但不仅限于浏览器、桌面应用、移动端应用、平板应用、甚至智能家居</p>
<p><img src="http://mdrs.yuanjin.tech/img/image-20200422163727151.png" alt="image-20200422163727151"></p>
<blockquote>
<p>实际上，不同的产品线通常有自己的服务器，产品内部的数据一般和自己的服务器交互。</p>
<p>但中心服务器仍然有必要存在，因为同一家公司的产品总是会存在共享的数据，比如用户数据</p>
</blockquote>
<p>这些设备与中心服务器之间会进行http通信</p>
<p>一般来说，中心服务器至少承担着认证和授权的功能，例如登录：各种设备发送消息到中心服务器，然后中心服务器响应一个身份令牌（参见<a href="http://www.yuanjin.tech/article/98" target="_blank" rel="noopener">cookie原理详解</a>）</p>
<p>当这种结构出现后，就出现一个问题：它们之间还能使用传统的cookie方式传递令牌信息吗？</p>
<p>其实，也是可以的🐶，因为cookie在传输中无非是一个消息头而已，只不过浏览器对这个消息头有特殊处理罢了。</p>
<p>但浏览器之外的设备肯定不喜欢cookie，因为浏览器有着对cookie完善的管理机制，但是在其他设备上，就需要开发者自己手动处理了</p>
<p>jwt的出现就是为了解决这个问题</p>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>jwt全称<code>Json Web Token</code>，强行翻译过来就是<code>json格式的互联网令牌</code>（算了，还是不要强行翻译了🐷）</p>
<p>它要解决的问题，就是为多种终端设备，提供<strong>统一的、安全的</strong>令牌格式</p>
<p><img src="http://mdrs.yuanjin.tech/img/image-20200422165350268.png" alt="image-20200422165350268"></p>
<p>因此，jwt只是一个令牌格式而已，你可以把它存储到cookie，也可以存储到localstorage，没有任何限制！</p>
<p>同样的，对于传输，你可以使用任何传输方式来传输jwt，一般来说，我们会使用消息头来传输它</p>
<p>比如，当登录成功后，服务器可以给客户端响应一个jwt：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">HTTP&#x2F;1.1 200 OK</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">...</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">set-cookie:token&#x3D;jwt令牌</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">authorization:jwt令牌</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">...</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">&#123;..., token:jwt令牌&#125;</span></pre></td></tr></table></figure>

<p>可以看到，jwt令牌可以出现在响应的任何一个地方，客户端和服务器自行约定即可。</p>
<blockquote>
<p>当然，它也可以出现在响应的多个地方，比如为了充分利用浏览器的cookie，同时为了照顾其他设备，也可以让jwt出现在<code>set-cookie</code>和<code>authorization或body</code>中，尽管这会增加额外的传输量。</p>
</blockquote>
<p>当客户端拿到令牌后，它要做的只有一件事：存储它。</p>
<p>你可以存储到任何位置，比如手机文件、PC文件、localstorage、cookie</p>
<p>当后续请求发生时，你只需要将它作为请求的一部分发送到服务器即可。</p>
<p>虽然jwt没有明确要求应该如何附带到请求中，但通常我们会使用如下的格式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">GET &#x2F;api&#x2F;resources HTTP&#x2F;1.1</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">...</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">authorization: bearer jwt令牌</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">...</span></pre></td></tr></table></figure>

<blockquote>
<p>这种格式是OAuth2附带token的一种规范格式</p>
<p>至于什么是OAuth2，那是另一个话题了</p>
</blockquote>
<p>这样一来，服务器就能够收到这个令牌了，通过对令牌的验证，即可知道该令牌是否有效。</p>
<p>它们的完整交互流程是非常简单清晰的</p>
<p><img src="http://mdrs.yuanjin.tech/img/image-20200422172837190.png" alt="image-20200422172837190"></p>
<h1 id="令牌的组成"><a href="#令牌的组成" class="headerlink" title="令牌的组成"></a>令牌的组成</h1><p>为了保证令牌的安全性，jwt令牌由三个部分组成，分别是：</p>
<ol>
<li>header：令牌头部，记录了整个令牌的类型和签名算法</li>
<li>payload：令牌负荷，记录了保存的主体信息，比如你要保存的用户信息就可以放到这里</li>
<li>signature：令牌签名，按照头部固定的签名算法对整个令牌进行签名，该签名的作用是：保证令牌不被伪造和篡改</li>
</ol>
<p>它们组合而成的完整格式是：<code>header.payload.signature</code></p>
<p>比如，一个完整的jwt令牌如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJmb28iOiJiYXIiLCJpYXQiOjE1ODc1NDgyMTV9.BCwUy3jnUQ_E6TqCayc7rCHkx-vxxdagUwPOWqwYCFc</span></pre></td></tr></table></figure>

<p>它各个部分的值分别是：</p>
<ul>
<li><code>header：eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9</code></li>
<li><code>payload：eyJmb28iOiJiYXIiLCJpYXQiOjE1ODc1NDgyMTV9</code></li>
<li><code>signature: BCwUy3jnUQ_E6TqCayc7rCHkx-vxxdagUwPOWqwYCFc</code></li>
</ul>
<p>下面分别对每个部分进行说明</p>
<h2 id="header"><a href="#header" class="headerlink" title="header"></a>header</h2><p>它是令牌头部，记录了整个令牌的类型和签名算法</p>
<p>它的格式是一个<code>json</code>对象，如下：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  <span class="attr">"alg"</span>:<span class="string">"HS256"</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">  <span class="attr">"typ"</span>:<span class="string">"JWT"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>该对象记录了：</p>
<ul>
<li>alg：signature部分使用的签名算法，通常可以取两个值<ul>
<li>HS256：一种对称加密算法，使用同一个秘钥对signature加密解密</li>
<li>RS256：一种非对称加密算法，使用私钥加密，公钥解密</li>
</ul>
</li>
<li>typ：整个令牌的类型，固定写<code>JWT</code>即可</li>
</ul>
<p>设置好了<code>header</code>之后，就可以生成<code>header</code>部分了</p>
<p>具体的生成方式及其简单，就是把<code>header</code>部分使用<code>base64 url</code>编码即可</p>
<blockquote>
<p><code>base64 url</code>不是一个加密算法，而是一种编码方式，它是在<code>base64</code>算法的基础上对<code>+</code>、<code>=</code>、<code>/</code>三个字符做出特殊处理的算法</p>
<p>而<code>base64</code>是使用64个可打印字符来表示一个二进制数据，具体的做法参考<a href="https://baike.baidu.com/item/base64/8545775?fr=aladdin" target="_blank" rel="noopener">百度百科</a></p>
</blockquote>
<p>浏览器提供了<code>btoa</code>函数，可以完成这个操作：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.btoa(<span class="built_in">JSON</span>.stringify(&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  <span class="string">"alg"</span>:<span class="string">"HS256"</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">  <span class="string">"typ"</span>:<span class="string">"JWT"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">&#125;))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 得到字符串：eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9</span></span></pre></td></tr></table></figure>

<p>同样的，浏览器也提供了<code>atob</code>函数，可以对其进行解码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.atob(<span class="string">"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9"</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 得到字符串：&#123;"alg":"HS256","typ":"JWT"&#125;</span></span></pre></td></tr></table></figure>

<blockquote>
<p>nodejs中没有提供这两个函数，可以安装第三方库<code>atob</code>和<code>bota</code>搞定</p>
<p>或者，手动搞定</p>
</blockquote>
<h2 id="payload"><a href="#payload" class="headerlink" title="payload"></a>payload</h2><p>这部分是jwt的主体信息，它仍然是一个JSON对象，它可以包含以下内容：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  "ss"："发行者",</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">	"iat"："发布时间",</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">	"exp"："到期时间",</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">	"sub"："主题",</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">	"aud"："听众",</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">	"nbf"："在此之前不可用",</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">  "jti"："JWT ID"</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>以上属性可以全写，也可以一个都不写，它只是一个规范，就算写了，也需要你在将来验证这个jwt令牌时手动处理才能发挥作用</p>
<p>上述属性表达的含义分别是：</p>
<ul>
<li>ss：发行该jwt的是谁，可以写公司名字，也可以写服务名称</li>
<li>iat：该jwt的发放时间，通常写当前时间的时间戳</li>
<li>exp：该jwt的到期时间，通常写时间戳</li>
<li>sub：该jwt是用于干嘛的</li>
<li>aud：该jwt是发放给哪个终端的，可以是终端类型，也可以是用户名称，随意一点</li>
<li>nbf：一个时间点，在该时间点到达之前，这个令牌是不可用的</li>
<li>jti：jwt的唯一编号，设置此项的目的，主要是为了防止重放攻击（重放攻击是在某些场景下，用户使用之前的令牌发送到服务器，被服务器正确的识别，从而导致不可预期的行为发生）</li>
</ul>
<p>可是到现在，看了半天，没有出现我想要写入的数据啊😂</p>
<p>当用户登陆成功之后，我可能需要把用户的一些信息写入到jwt令牌中，比如用户id、账号等等（密码就算了😳）</p>
<p>其实很简单，payload这一部分只是一个json对象而已，你可以向对象中加入任何想要加入的信息</p>
<p>比如，下面的json对象仍然是一个有效的payload</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  <span class="attr">"foo"</span>:<span class="string">"bar"</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">  <span class="attr">"iat"</span>:<span class="number">1587548215</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p><code>foo: bar</code>是我们自定义的信息，<code>iat: 1587548215</code>是jwt规范中的信息</p>
<p>最终，payload部分和header一样，需要通过<code>base64 url</code>编码得到：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.btoa(<span class="built_in">JSON</span>.stringify(&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  <span class="string">"foo"</span>:<span class="string">"bar"</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">  <span class="string">"iat"</span>:<span class="number">1587548215</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">&#125;))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 得到字符串：eyJmb28iOiJiYXIiLCJpYXQiOjE1ODc1NDgyMTV9</span></span></pre></td></tr></table></figure>

<h2 id="signature"><a href="#signature" class="headerlink" title="signature"></a>signature</h2><p>这一部分是jwt的签名，正是它的存在，保证了整个jwt不被篡改</p>
<p>这部分的生成，是对前面两个部分的编码结果，按照头部指定的方式进行加密</p>
<p>比如：头部指定的加密方法是<code>HS256</code>，前面两部分的编码结果是<code>eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJmb28iOiJiYXIiLCJpYXQiOjE1ODc1NDgyMTV9</code></p>
<p>则第三部分就是用对称加密算法<code>HS256</code>对字符串<code>eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJmb28iOiJiYXIiLCJpYXQiOjE1ODc1NDgyMTV9</code>进行加密，当然你得指定一个秘钥，比如<code>shhhhh</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">HS256(<span class="string">`eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJmb28iOiJiYXIiLCJpYXQiOjE1ODc1NDgyMTV9`</span>, <span class="string">"shhhhh"</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 得到：BCwUy3jnUQ_E6TqCayc7rCHkx-vxxdagUwPOWqwYCFc</span></span></pre></td></tr></table></figure>

<p>最终，将三部分组合在一起，就得到了完整的jwt</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJmb28iOiJiYXIiLCJpYXQiOjE1ODc1NDgyMTV9.BCwUy3jnUQ_E6TqCayc7rCHkx-vxxdagUwPOWqwYCFc</span></pre></td></tr></table></figure>

<p>由于签名使用的秘钥保存在服务器，这样一来，客户端就无法伪造出签名，因为它拿不到秘钥。</p>
<p>换句话说，之所以说无法伪造jwt，就是因为第三部分的存在。</p>
<p>而前面两部分并没有加密，只是一个编码结果而已，可以认为几乎是明文传输</p>
<blockquote>
<p>这不会造成太大的问题，因为既然用户登陆成功了，它当然有权力查看自己的用户信息</p>
<p>甚至在某些网站，用户的基本信息可以被任何人查看</p>
<p>你要保证的，是不要把敏感的信息存放到jwt中，比如密码</p>
</blockquote>
<p>jwt的<code>signature</code>可以保证令牌不被伪造，那如何保证令牌不被篡改呢？</p>
<p>比如，某个用户登陆成功了，获得了jwt，但他人为的篡改了<code>payload</code>，比如把自己的账户余额修改为原来的两倍，然后重新编码出<code>payload</code>发送到服务器，服务器如何得知这些信息被篡改过了呢？</p>
<p>这就要说到令牌的验证了</p>
<h1 id="令牌的验证"><a href="#令牌的验证" class="headerlink" title="令牌的验证"></a>令牌的验证</h1><p><img src="http://mdrs.yuanjin.tech/img/image-20200422172837190.png" alt="image-20200422172837190"></p>
<p>令牌在服务器组装完成后，会以任意的方式发送到客户端</p>
<p>客户端会把令牌保存起来，后续的请求会将令牌发送给服务器</p>
<p>而服务器需要验证令牌是否正确，如何验证呢？</p>
<p>首先，服务器要验证这个令牌是否被篡改过，验证方式非常简单，就是对<code>header+payload</code>用同样的秘钥和加密算法进行重新加密</p>
<p>然后把加密的结果和传入jwt的<code>signature</code>进行对比，如果完全相同，则表示前面两部分没有动过，就是自己颁发的，如果不同，肯定是被篡改过了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">传入的header.传入的payload.传入的signature</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">新的signature &#x3D; header中的加密算法(传入的header.传入的payload, 秘钥)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">验证：新的signature &#x3D;&#x3D; 传入的signature</span></pre></td></tr></table></figure>

<p>当令牌验证为没有被篡改后，服务器可以进行其他验证：比如是否过期、听众是否满足要求等等，这些就视情况而定了</p>
<p>注意：这些验证都需要服务器手动完成，没有哪个服务器会给你进行自动验证，当然，你可以借助第三方库来完成这些操作</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>最后，总结一下jwt的特点：</p>
<ul>
<li>jwt本质上是一种令牌格式。它和终端设备无关，同样和服务器无关，甚至与如何传输无关，它只是规范了令牌的格式而已</li>
<li>jwt由三部分组成：header、payload、signature。主体信息在payload</li>
<li>jwt难以被篡改和伪造。这是因为有第三部分的签名存在。</li>
</ul>

      
      <!-- 打赏 -->
      
    </div>
    <footer class="article-footer">
      <a data-url="https://huafuhub.github.io/blog/2020/11/09/JWTa/" data-id="ckhacid51000b74w17wy4ggb8"
        class="article-share-link">分享</a>
      
    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-CORSa" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/blog/2020/11/09/CORSa/"
    >CORS原理详解</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/blog/2020/11/09/CORSa/" class="article-date">
  <time datetime="2020-11-09T08:25:57.000Z" itemprop="datePublished">2020-11-09</time>
</a>
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      


      

      
      <blockquote>
<p>阅读本文，你需要首先知道：</p>
<ol>
<li>浏览器的同源策略</li>
<li>跨域问题</li>
<li>JSONP原理</li>
<li>cookie原理</li>
</ol>
</blockquote>
<p>JSONP并不是一个好的跨域解决方案，它至少有着下面两个严重问题：</p>
<ol>
<li><strong>会打乱服务器的消息格式</strong>：JSONP要求服务器响应一段JS代码，但在非跨域的情况下，服务器又需要响应一个正常的JSON格式</li>
<li><strong>只能完成GET请求</strong>：JSONP的原理会要求浏览器端生成一个<code>script</code>元素，而<code>script</code>元素发出的请求只能是<code>get</code>请求</li>
</ol>
<p>所以，CORS是一种更好的跨域解决方案。</p>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p><code>CORS</code>是基于<code>http1.1</code>的一种跨域解决方案，它的全称是<strong>C</strong>ross-<strong>O</strong>rigin <strong>R</strong>esource <strong>S</strong>haring，跨域资源共享。</p>
<p>它的总体思路是：<strong>如果浏览器要跨域访问服务器的资源，需要获得服务器的允许</strong></p>
<p><img src="http://mdrs.yuanjin.tech/img/image-20200421152122793.png" alt="image-20200421152122793"></p>
<p>而要知道，一个请求可以附带很多信息，从而会对服务器造成不同程度的影响</p>
<p>比如有的请求只是获取一些新闻，有的请求会改动服务器的数据</p>
<p>针对不同的请求，CORS规定了三种不同的交互模式，分别是：</p>
<ul>
<li><strong>简单请求</strong></li>
<li><strong>需要预检的请求</strong></li>
<li><strong>附带身份凭证的请求</strong></li>
</ul>
<p>这三种模式从上到下层层递进，请求可以做的事越来越多，要求也越来越严格。</p>
<p>下面分别说明三种请求模式的具体规范。</p>
<h1 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h1><p>当浏览器端运行了一段ajax代码（无论是使用XMLHttpRequest还是fetch api），浏览器会首先判断它属于哪一种请求模式</p>
<h2 id="简单请求的判定"><a href="#简单请求的判定" class="headerlink" title="简单请求的判定"></a>简单请求的判定</h2><p>当请求<strong>同时满足</strong>以下条件时，浏览器会认为它是一个简单请求：</p>
<ol>
<li><p><strong>请求方法属于下面的一种：</strong></p>
<ul>
<li>get</li>
<li>post</li>
<li>head</li>
</ul>
</li>
<li><p><strong>请求头仅包含安全的字段，常见的安全字段如下：</strong></p>
<ul>
<li><code>Accept</code></li>
<li><code>Accept-Language</code></li>
<li><code>Content-Language</code></li>
<li><code>Content-Type</code></li>
<li><code>DPR</code></li>
<li><code>Downlink</code></li>
<li><code>Save-Data</code></li>
<li><code>Viewport-Width</code></li>
<li><code>Width</code></li>
</ul>
</li>
<li><p><strong>请求头如果包含<code>Content-Type</code>，仅限下面的值之一：</strong></p>
<ul>
<li><code>text/plain</code></li>
<li><code>multipart/form-data</code></li>
<li><code>application/x-www-form-urlencoded</code></li>
</ul>
</li>
</ol>
<p>如果以上三个条件同时满足，浏览器判定为简单请求。</p>
<p>下面是一些例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简单请求</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">fetch(<span class="string">"http://crossdomain.com/api/news"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 请求方法不满足要求，不是简单请求</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">fetch(<span class="string">"http://crossdomain.com/api/news"</span>, &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">  method:<span class="string">"PUT"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加入了额外的请求头，不是简单请求</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">fetch(<span class="string">"http://crossdomain.com/api/news"</span>, &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">  headers:&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    a: <span class="number">1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简单请求</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">fetch(<span class="string">"http://crossdomain.com/api/news"</span>, &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">  method: <span class="string">"post"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// content-type不满足要求，不是简单请求</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">fetch(<span class="string">"http://crossdomain.com/api/news"</span>, &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">  method: <span class="string">"post"</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">  headers: &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">    <span class="string">"content-type"</span>: <span class="string">"application/json"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>

<h2 id="简单请求的交互规范"><a href="#简单请求的交互规范" class="headerlink" title="简单请求的交互规范"></a>简单请求的交互规范</h2><p>当浏览器判定某个<strong>ajax跨域请求</strong>是<strong>简单请求</strong>时，会发生以下的事情</p>
<ol>
<li><strong>请求头中会自动添加<code>Origin</code>字段</strong></li>
</ol>
<p>比如，在页面<code>http://my.com/index.html</code>中有以下代码造成了跨域</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简单请求</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">fetch(<span class="string">"http://crossdomain.com/api/news"</span>);</span></pre></td></tr></table></figure>

<p>请求发出后，请求头会是下面的格式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">GET &#x2F;api&#x2F;news&#x2F; HTTP&#x2F;1.1</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">Host: crossdomain.com</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">Connection: keep-alive</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">...</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">Referer: http:&#x2F;&#x2F;my.com&#x2F;index.html</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">Origin: http:&#x2F;&#x2F;my.com</span></pre></td></tr></table></figure>

<p>看到最后一行没，<code>Origin</code>字段会告诉服务器，是哪个源地址在跨域请求</p>
<ol start="2">
<li><strong>服务器响应头中应包含<code>Access-Control-Allow-Origin</code></strong></li>
</ol>
<p>当服务器收到请求后，如果允许该请求跨域访问，需要在响应头中添加<code>Access-Control-Allow-Origin</code>字段</p>
<p>该字段的值可以是：</p>
<ul>
<li>*：表示我很开放，什么人我都允许访问</li>
<li>具体的源：比如<code>http://my.com</code>，表示我就允许你访问</li>
</ul>
<blockquote>
<p>实际上，这两个值对于客户端<code>http://my.com</code>而言，都一样，因为客户端才不会管其他源服务器允不允许，就关心自己是否被允许</p>
<p>当然，服务器也可以维护一个可被允许的源列表，如果请求的<code>Origin</code>命中该列表，才响应<code>*</code>或具体的源</p>
<p><strong>为了避免后续的麻烦，强烈推荐响应具体的源</strong></p>
</blockquote>
<p>假设服务器做出了以下的响应：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">HTTP&#x2F;1.1 200 OK</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">Date: Tue, 21 Apr 2020 08:03:35 GMT</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">...</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Origin: http:&#x2F;&#x2F;my.com</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">...</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">消息体中的数据</span></pre></td></tr></table></figure>

<p>当浏览器看到服务器允许自己访问后，高兴的像一个两百斤的孩子，于是，它就把响应顺利的交给js，以完成后续的操作</p>
<p>下图简述了整个交互过程</p>
<p><img src="http://mdrs.yuanjin.tech/img/image-20200421162846480.png" alt="image-20200421162846480"></p>
<h1 id="需要预检的请求"><a href="#需要预检的请求" class="headerlink" title="需要预检的请求"></a>需要预检的请求</h1><p>简单的请求对服务器的威胁不大，所以允许使用上述的简单交互即可完成。</p>
<p>但是，如果浏览器不认为这是一种简单请求，就会按照下面的流程进行：</p>
<ol>
<li><strong>浏览器发送预检请求，询问服务器是否允许</strong></li>
<li><strong>服务器允许</strong></li>
<li><strong>浏览器发送真实请求</strong></li>
<li><strong>服务器完成真实的响应</strong></li>
</ol>
<p>比如，在页面<code>http://my.com/index.html</code>中有以下代码造成了跨域</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需要预检的请求</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">fetch(<span class="string">"http://crossdomain.com/api/user"</span>, &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">  method:<span class="string">"POST"</span>, <span class="comment">// post 请求</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">  headers:&#123;  <span class="comment">// 设置请求头</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    a: <span class="number">1</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    b: <span class="number">2</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="string">"content-type"</span>: <span class="string">"application/json"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">  &#125;,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">  body: <span class="built_in">JSON</span>.stringify(&#123; <span class="attr">name</span>: <span class="string">"袁小进"</span>, <span class="attr">age</span>: <span class="number">18</span> &#125;) <span class="comment">// 设置请求体</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr></table></figure>

<p>浏览器发现它不是一个简单请求，则会按照下面的流程与服务器交互</p>
<ol>
<li><strong>浏览器发送预检请求，询问服务器是否允许</strong></li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">OPTIONS &#x2F;api&#x2F;user HTTP&#x2F;1.1</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">Host: crossdomain.com</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">...</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">Origin: http:&#x2F;&#x2F;my.com</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">Access-Control-Request-Method: POST</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">Access-Control-Request-Headers: a, b, content-type</span></pre></td></tr></table></figure>

<p>可以看出，这并非我们想要发出的真实请求，请求中不包含我们的响应头，也没有消息体。</p>
<p>这是一个预检请求，它的目的是询问服务器，是否允许后续的真实请求。</p>
<p>预检请求<strong>没有请求体</strong>，它包含了后续真实请求要做的事情</p>
<p>预检请求有以下特征：</p>
<ul>
<li>请求方法为<code>OPTIONS</code></li>
<li>没有请求体</li>
<li>请求头中包含<ul>
<li><code>Origin</code>：请求的源，和简单请求的含义一致</li>
<li><code>Access-Control-Request-Method</code>：后续的真实请求将使用的请求方法</li>
<li><code>Access-Control-Request-Headers</code>：后续的真实请求会改动的请求头</li>
</ul>
</li>
</ul>
<ol start="2">
<li><strong>服务器允许</strong></li>
</ol>
<p>服务器收到预检请求后，可以检查预检请求中包含的信息，如果允许这样的请求，需要响应下面的消息格式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">HTTP&#x2F;1.1 200 OK</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">Date: Tue, 21 Apr 2020 08:03:35 GMT</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">...</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Origin: http:&#x2F;&#x2F;my.com</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Methods: POST</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Headers: a, b, content-type</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">Access-Control-Max-Age: 86400</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">...</span></pre></td></tr></table></figure>

<p>对于预检请求，不需要响应任何的消息体，只需要在响应头中添加：</p>
<ul>
<li><code>Access-Control-Allow-Origin</code>：和简单请求一样，表示允许的源</li>
<li><code>Access-Control-Allow-Methods</code>：表示允许的后续真实的请求方法</li>
<li><code>Access-Control-Allow-Headers</code>：表示允许改动的请求头</li>
<li><code>Access-Control-Max-Age</code>：告诉浏览器，多少秒内，对于同样的请求源、方法、头，都不需要再发送预检请求了</li>
</ul>
<ol start="3">
<li><strong>浏览器发送真实请求</strong></li>
</ol>
<p>预检被服务器允许后，浏览器就会发送真实请求了，上面的代码会发生下面的请求数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">POST &#x2F;api&#x2F;user HTTP&#x2F;1.1</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">Host: crossdomain.com</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">Connection: keep-alive</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">...</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">Referer: http:&#x2F;&#x2F;my.com&#x2F;index.html</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">Origin: http:&#x2F;&#x2F;my.com</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">&#123;&quot;name&quot;: &quot;袁小进&quot;, &quot;age&quot;: 18 &#125;</span></pre></td></tr></table></figure>

<ol start="4">
<li><strong>服务器响应真实请求</strong></li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">HTTP&#x2F;1.1 200 OK</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">Date: Tue, 21 Apr 2020 08:03:35 GMT</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">...</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Origin: http:&#x2F;&#x2F;my.com</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">...</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">添加用户成功</span></pre></td></tr></table></figure>



<p>可以看出，当完成预检之后，后续的处理与简单请求相同</p>
<p>下图简述了整个交互过程</p>
<p><img src="http://mdrs.yuanjin.tech/img/image-20200421165913320.png" alt="image-20200421165913320"></p>
<h1 id="附带身份凭证的请求"><a href="#附带身份凭证的请求" class="headerlink" title="附带身份凭证的请求"></a>附带身份凭证的请求</h1><p>默认情况下，ajax的跨域请求并不会附带cookie，这样一来，某些需要权限的操作就无法进行</p>
<p>不过可以通过简单的配置就可以实现附带cookie</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// xhr</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">xhr.withCredentials = <span class="literal">true</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// fetch api</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">fetch(url, &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">  credentials: <span class="string">"include"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>

<p>这样一来，该跨域的ajax请求就是一个<em>附带身份凭证的请求</em></p>
<p>当一个请求需要附带cookie时，无论它是简单请求，还是预检请求，都会在请求头中添加<code>cookie</code>字段</p>
<p>而服务器响应时，需要明确告知客户端：服务器允许这样的凭据</p>
<p>告知的方式也非常的简单，只需要在响应头中添加：<code>Access-Control-Allow-Credentials: true</code>即可</p>
<p>对于一个附带身份凭证的请求，若服务器没有明确告知，浏览器仍然视为跨域被拒绝。</p>
<p>另外要特别注意的是：<strong>对于附带身份凭证的请求，服务器不得设置 <code>Access-Control-Allow-Origin 的值为*</code></strong>。这就是为什么不推荐使用*的原因</p>
<h1 id="一个额外的补充"><a href="#一个额外的补充" class="headerlink" title="一个额外的补充"></a>一个额外的补充</h1><p>在跨域访问时，JS只能拿到一些最基本的响应头，如：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma，如果要访问其他头，则需要服务器设置本响应头。</p>
<p><code>Access-Control-Expose-Headers</code>头让服务器把允许浏览器访问的头放入白名单，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">Access-Control-Expose-Headers: authorization, a, b</span></pre></td></tr></table></figure>

<p>这样JS就能够访问指定的响应头了。</p>

      
      <!-- 打赏 -->
      
    </div>
    <footer class="article-footer">
      <a data-url="https://huafuhub.github.io/blog/2020/11/09/CORSa/" data-id="ckhacid4i000074w166603yz3"
        class="article-share-link">分享</a>
      
    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-Cookiea" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/blog/2020/11/09/Cookiea/"
    >cookie的基本概念</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/blog/2020/11/09/Cookiea/" class="article-date">
  <time datetime="2020-11-09T08:24:27.000Z" itemprop="datePublished">2020-11-09</time>
</a>
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      


      

      
      <h1 id="一个不大不小的问题"><a href="#一个不大不小的问题" class="headerlink" title="一个不大不小的问题"></a>一个不大不小的问题</h1><p>假设服务器有一个接口，通过请求这个接口，可以添加一个管理员</p>
<p>但是，不是任何人都有权力做这种操作的</p>
<p>那么服务器如何知道请求接口的人是有权力的呢？</p>
<p>答案是：只有登录过的管理员才能做这种操作</p>
<p>可问题是，客户端和服务器的传输使用的是http协议，http协议是无状态的，什么叫无状态，就是<strong>服务器不知道这一次请求的人，跟之前登录请求成功的人是不是同一个人</strong></p>
<p><img src="http://mdrs.yuanjin.tech/img/image-20200417161014030.png" alt=""></p>
<p><img src="http://mdrs.yuanjin.tech/img/image-20200417161244373.png" alt=""></p>
<p>由于http协议的无状态，服务器<strong>忘记</strong>了之前的所有请求，它无法确定这一次请求的客户端，就是之前登录成功的那个客户端。</p>
<blockquote>
<p>你可以把服务器想象成有着严重脸盲症的东哥，他没有办法分清楚跟他说话的人之前做过什么</p>
</blockquote>
<p>于是，服务器想了一个办法</p>
<p>它按照下面的流程来认证客户端的身份</p>
<ol>
<li>客户端登录成功后，服务器会给客户端一个出入证（令牌 token）</li>
<li>后续客户端的每次请求，都必须要附带这个出入证（令牌 token）</li>
</ol>
<p><img src="http://mdrs.yuanjin.tech/img/image-20200417161950450.png" alt=""></p>
<p>服务器发扬了认证不认人的优良传统，就可以很轻松的识别身份了。</p>
<p>但是，用户不可能只在一个网站登录，于是客户端会收到来自各个网站的出入证，因此，就要求客户端要有一个类似于卡包的东西，能够具备下面的功能：</p>
<ol>
<li><strong>能够存放多个出入证</strong>。这些出入证来自不同的网站，也可能是一个网站有多个出入证，分别用于出入不同的地方</li>
<li><strong>能够自动出示出入证</strong>。客户端在访问不同的网站时，能够自动的把对应的出入证附带请求发送出去。</li>
<li><strong>正确的出示出入证</strong>。客户端不能将肯德基的出入证发送给麦当劳。</li>
<li><strong>管理出入证的有效期</strong>。客户端要能够自动的发现那些已经过期的出入证，并把它从卡包内移除。</li>
</ol>
<p>能够满足上面所有要求的，就是cookie</p>
<p>cookie类似于一个卡包，专门用于存放各种出入证，并有着一套机制来自动管理这些证件。</p>
<p>卡包内的每一张卡片，称之为<strong>一个cookie</strong>。</p>
<h1 id="cookie的组成"><a href="#cookie的组成" class="headerlink" title="cookie的组成"></a>cookie的组成</h1><p>cookie是浏览器中特有的一个概念，它就像浏览器的专属卡包，管理着各个网站的身份信息。</p>
<p>每个cookie就相当于是属于某个网站的一个卡片，它记录了下面的信息：</p>
<ul>
<li>key：键，比如「身份编号」</li>
<li>value：值，比如袁小进的身份编号「14563D1550F2F76D69ECBF4DD54ABC95」，这有点像卡片的条形码，当然，它可以是任何信息</li>
<li>domain：域，表达这个cookie是属于哪个网站的，比如<code>yuanjin.tech</code>，表示这个cookie是属于<code>yuanjin.tech</code>这个网站的</li>
<li>path：路径，表达这个cookie是属于该网站的哪个基路径的，就好比是同一家公司不同部门会颁发不同的出入证。比如<code>/news</code>，表示这个cookie属于<code>/news</code>这个路径的。（后续详细解释）</li>
<li>secure：是否使用安全传输（后续详细解释）</li>
<li>expire：过期时间，表示该cookie在什么时候过期</li>
</ul>
<p>当浏览器向服务器发送一个请求的时候，它会瞄一眼自己的卡包，看看哪些卡片适合附带捎给服务器</p>
<p>如果一个cookie<strong>同时满足</strong>以下条件，则这个cookie会被附带到请求中</p>
<ul>
<li>cookie没有过期</li>
<li>cookie中的域和这次请求的域是匹配的<ul>
<li>比如cookie中的域是<code>yuanjin.tech</code>，则可以匹配的请求域是<code>yuanjin.tech</code>、<code>www.yuanjin.tech</code>、<code>blogs.yuanjin.tech</code>等等</li>
<li>比如cookie中的域是<code>www.yuanjin.tech</code>，则只能匹配<code>www.yuanjin.tech</code>这样的请求域</li>
<li>cookie是不在乎端口的，只要域匹配即可</li>
</ul>
</li>
<li>cookie中的path和这次请求的path是匹配的<ul>
<li>比如cookie中的path是<code>/news</code>，则可以匹配的请求路径可以是<code>/news</code>、<code>/news/detail</code>、<code>/news/a/b/c</code>等等，但不能匹配<code>/blogs</code></li>
<li>如果cookie的path是<code>/</code>，可以想象，能够匹配所有的路径</li>
</ul>
</li>
<li>验证cookie的安全传输<ul>
<li>如果cookie的secure属性是true，则请求协议必须是<code>https</code>，否则不会发送该cookie</li>
<li>如果cookie的secure属性是false，则请求协议可以是<code>http</code>，也可以是<code>https</code></li>
</ul>
</li>
</ul>
<p>如果一个cookie满足了上述的所有条件，则浏览器会把它自动加入到这次请求中</p>
<p>具体加入的方式是，<strong>浏览器会将符合条件的cookie，自动放置到请求头中</strong>，例如，当我在浏览器中访问百度的时候，它在请求头中附带了下面的cookie：</p>
<p><img src="http://mdrs.yuanjin.tech/img/image-20200417170328584.png" alt=""></p>
<p>看到打马赛克的地方了吗？这部分就是通过请求头<code>cookie</code>发送到服务器的，它的格式是<code>键=值; 键=值; 键=值; ...</code>，每一个键值对就是一个符合条件的cookie。</p>
<p><strong>cookie中包含了重要的身份信息，永远不要把你的cookie泄露给别人！！！</strong>否则，他人就拿到了你的证件，有了证件，就具备了为所欲为的可能性。</p>
<h1 id="如何设置cookie"><a href="#如何设置cookie" class="headerlink" title="如何设置cookie"></a>如何设置cookie</h1><p>由于cookie是保存在浏览器端的，同时，很多证件又是服务器颁发的</p>
<p>所以，cookie的设置有两种模式：</p>
<ul>
<li>服务器响应：这种模式是非常普遍的，当服务器决定给客户端颁发一个证件时，它会在响应的消息中包含cookie，浏览器会自动的把cookie保存到卡包中</li>
<li>客户端自行设置：这种模式少见一些，不过也有可能会发生，比如用户关闭了某个广告，并选择了「以后不要再弹出」，此时就可以把这种小信息直接通过浏览器的JS代码保存到cookie中。后续请求服务器时，服务器会看到客户端不想要再次弹出广告的cookie，于是就不会再发送广告过来了。</li>
</ul>
<h2 id="服务器端设置cookie"><a href="#服务器端设置cookie" class="headerlink" title="服务器端设置cookie"></a>服务器端设置cookie</h2><p>服务器可以通过设置响应头，来告诉浏览器应该如何设置cookie</p>
<p>响应头按照下面的格式设置：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="attr">set-cookie:</span> <span class="string">cookie1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="attr">set-cookie:</span> <span class="string">cookie2</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="attr">set-cookie:</span> <span class="string">cookie3</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="string">...</span></span></pre></td></tr></table></figure>

<p>通过这种模式，就可以在一次响应中设置多个cookie了，具体设置多少个cookie，设置什么cookie，根据你的需要自行处理</p>
<p>其中，每个cookie的格式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">键&#x3D;值; path&#x3D;?; domain&#x3D;?; expire&#x3D;?; max-age&#x3D;?; secure; httponly</span></pre></td></tr></table></figure>

<p>每个cookie除了键值对是必须要设置的，其他的属性都是可选的，并且顺序不限</p>
<p>当这样的响应头到达客户端后，<strong>浏览器会自动的将cookie保存到卡包中，如果卡包中已经存在一模一样的卡片（其他key、path、domain相同），则会自动的覆盖之前的设置</strong>。</p>
<p>下面，依次说明每个属性值：</p>
<ul>
<li><strong>path</strong>：设置cookie的路径。如果不设置，浏览器会将其自动设置为当前请求的路径。比如，浏览器请求的地址是<code>/login</code>，服务器响应了一个<code>set-cookie: a=1</code>，浏览器会将该cookie的path设置为请求的路径<code>/login</code></li>
<li><strong>domain</strong>：设置cookie的域。如果不设置，浏览器会自动将其设置为当前的请求域，比如，浏览器请求的地址是<code>http://www.yuanjin.tech</code>，服务器响应了一个<code>set-cookie: a=1</code>，浏览器会将该cookie的domain设置为请求的域<code>www.yuanjin.tech</code><ul>
<li>这里值得注意的是，如果服务器响应了一个无效的域，浏览器是不认的</li>
<li>什么是无效的域？就是响应的域连根域都不一样。比如，浏览器请求的域是<code>yuanjin.tech</code>，服务器响应的cookie是<code>set-cookie: a=1; domain=baidu.com</code>，这样的域浏览器是不认的。</li>
<li>如果浏览器连这样的情况都允许，就意味着张三的服务器，有权利给用户一个cookie，用于访问李四的服务器，这会造成很多安全性的问题</li>
</ul>
</li>
<li><strong>expire</strong>：设置cookie的过期时间。这里必须是一个有效的GMT时间，即格林威治标准时间字符串，比如<code>Fri, 17 Apr 2020 09:35:59 GMT</code>，表示格林威治时间的<code>2020-04-17 09:35:59</code>，即北京时间的<code>2020-04-17 17:35:59</code>。当客户端的时间达到这个时间点后，会自动销毁该cookie。</li>
<li><strong>max-age</strong>：设置cookie的相对有效期。expire和max-age通常仅设置一个即可。比如设置<code>max-age</code>为<code>1000</code>，浏览器在添加cookie时，会自动设置它的<code>expire</code>为当前时间加上1000秒，作为过期时间。<ul>
<li>如果不设置expire，又没有设置max-age，则表示会话结束后过期。</li>
<li>对于大部分浏览器而言，关闭所有浏览器窗口意味着会话结束。</li>
</ul>
</li>
<li><strong>secure</strong>：设置cookie是否是安全连接。如果设置了该值，则表示该cookie后续只能随着<code>https</code>请求发送。如果不设置，则表示该cookie会随着所有请求发送。</li>
<li><strong>httponly</strong>：设置cookie是否仅能用于传输。如果设置了该值，表示该cookie仅能用于传输，而不允许在客户端通过JS获取，这对防止跨站脚本攻击（XSS）会很有用。 <ul>
<li>关于如何通过JS获取，后续会讲解</li>
<li>关于什么是XSS，不在本文讨论范围</li>
</ul>
</li>
</ul>
<p>下面来一个例子，客户端通过<code>post</code>请求服务器<code>http://yuanjin.tech/login</code>，并在消息体中给予了账号和密码，服务器验证登录成功后，在响应头中加入了以下内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">set-cookie: token&#x3D;123456; path&#x3D;&#x2F;; max-age&#x3D;3600; httponly</span></pre></td></tr></table></figure>

<p>当该响应到达浏览器后，浏览器会创建下面的cookie：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="attr">key:</span> <span class="string">token</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="attr">value:</span> <span class="number">123456</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="attr">domain:</span> <span class="string">yuanjin.tech</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="attr">path:</span> <span class="string">/</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="attr">expire:</span> <span class="number">2020</span><span class="number">-04</span><span class="number">-17</span> <span class="number">18</span><span class="string">:55:00</span> <span class="comment">#假设当前时间是2020-04-17 17:55:00</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="attr">secure:</span> <span class="literal">false</span>  <span class="comment">#任何请求都可以附带这个cookie，只要满足其他要求</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="attr">httponly:</span> <span class="literal">true</span> <span class="comment">#不允许JS获取该cookie</span></span></pre></td></tr></table></figure>

<p>于是，随着浏览器后续对服务器的请求，只要满足要求，这个cookie就会被附带到请求头中传给服务器：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="attr">cookie:</span> <span class="string">token=123456;</span> <span class="string">其他cookie...</span></span></pre></td></tr></table></figure>

<p>现在，还剩下最后一个问题，就是如何删除浏览器的一个cookie呢？</p>
<p>如果要删除浏览器的cookie，只需要让服务器响应一个同样的域、同样的路径、同样的key，只是时间过期的cookie即可</p>
<p><strong>所以，删除cookie其实就是修改cookie</strong></p>
<p>下面的响应会让浏览器删除<code>token</code></p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="attr">cookie:</span> <span class="string">token=;</span> <span class="string">domain=yuanjin.tech;</span> <span class="string">path=/;</span> <span class="string">max-age=-1</span></span></pre></td></tr></table></figure>

<p>浏览器按照要求修改了cookie后，会发现cookie已经过期，于是自然就会删除了。</p>
<blockquote>
<p>无论是修改还是删除，都要注意cookie的域和路径，因为完全可能存在域或路径不同，但key相同的cookie</p>
<p>因此无法仅通过key确定是哪一个cookie</p>
</blockquote>
<h2 id="客户端设置cookie"><a href="#客户端设置cookie" class="headerlink" title="客户端设置cookie"></a>客户端设置cookie</h2><p>既然cookie是存放在浏览器端的，所以浏览器向JS公开了接口，让其可以设置cookie</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.cookie = <span class="string">"键=值; path=?; domain=?; expire=?; max-age=?; secure"</span>;</span></pre></td></tr></table></figure>

<p>可以看出，在客户端设置cookie，和服务器设置cookie的格式一样，只是有下面的不同</p>
<ul>
<li>没有httponly。因为httponly本来就是为了限制在客户端访问的，既然你是在客户端配置，自然失去了限制的意义。</li>
<li>path的默认值。在服务器端设置cookie时，如果没有写path，使用的是请求的path。而在客户端设置cookie时，也许根本没有请求发生。因此，path在客户端设置时的默认值是当前网页的path</li>
<li>domain的默认值。和path同理，客户端设置时的默认值是当前网页的domain</li>
<li>其他：一样</li>
<li>删除cookie：和服务器也一样，修改cookie的过期时间即可</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>以上，就是cookie原理部分的内容。</p>
<p>如果把它用于登录场景，就是如下的流程：</p>
<p><strong>登录请求</strong></p>
<ol>
<li>浏览器发送请求到服务器，附带账号密码</li>
<li>服务器验证账号密码是否正确，如果不正确，响应错误，如果正确，在响应头中设置cookie，附带登录认证信息（至于登录认证信息是设么样的，如何设计，要考虑哪些问题，就是另一个话题了，可以百度 jwt）</li>
<li>客户端收到cookie，浏览器自动记录下来</li>
</ol>
<p><strong>后续请求</strong></p>
<ol>
<li>浏览器发送请求到服务器，希望添加一个管理员，并将cookie自动附带到请求中</li>
<li>服务器先获取cookie，验证cookie中的信息是否正确，如果不正确，不予以操作，如果正确，完成正常的业务流程</li>
</ol>

      
      <!-- 打赏 -->
      
    </div>
    <footer class="article-footer">
      <a data-url="https://huafuhub.github.io/blog/2020/11/09/Cookiea/" data-id="ckhacid4r000374w1ht7t3h7u"
        class="article-share-link">分享</a>
      
    </footer>

  </div>

  

  
  
  

  

</article>
    
  </article>
  

  
  <nav class="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/blog/page/2/">2</a><a class="page-number" href="/blog/page/3/">3</a><a class="extend next" rel="next" href="/blog/page/2/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul class="list-inline">
      <li>
        &copy;
        2020
        Huafu Li
      </li>
      <li>
        
          Powered by
        
        
        <a href="https://hexo.io" target="_blank">Hexo</a> Theme <a href="https://github.com/Shen-Yu/hexo-theme-ayer" target="_blank">Ayer</a>
        
      </li>
    </ul>
    <ul class="list-inline">
      <li>
        
        
        <ul class="list-inline">
  <li>PV:<span id="busuanzi_value_page_pv"></span></li>
  <li>UV:<span id="busuanzi_value_site_uv"></span></li>
</ul>
        
      </li>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>
    <div class="to_top">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>
      </div>
    </main>
    
      <aside class="sidebar">
        
        <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/blog/"><img src="http://localhost:4000/blog/mouse.svg" alt="“鼠”于Huafu的“2”！"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/blog/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/blog/archives">目录</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/blog/about">关于</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/blog/pictures">相册</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/blog/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
      </aside>
      <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/blog/./images/alipay.png">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/blog/./images/wechat.png">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
      <script src="/blog/js/jquery-2.0.3.min.js"></script>
<script src="/blog/js/jquery.justifiedGallery.min.js"></script>
<script src="/blog/js/lazyload.min.js"></script>
<script src="/blog/js/busuanzi-2.3.pure.min.js"></script>

  <script src="/blog/fancybox/jquery.fancybox.min.js"></script>




<script>
  var ayerConfig = {
    mathjax: false
  }
</script>

<script src="/blog/js/ayer.js"></script>

<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">



<script type="text/javascript" src="https://js.users.51.la/20544303.js"></script>
  
  

  </div>
</body>

</html>